<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zone Presence Tracker</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: #0f0f1a;
            color: #fff;
            min-height: 100vh;
        }

        .app {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 20px 0;
            border-bottom: 1px solid #333;
            margin-bottom: 20px;
        }

        header h1 {
            font-size: 1.5rem;
            color: #4ecdc4;
        }

        /* Steps */
        .steps {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 30px;
        }

        .step {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 20px;
            background: #1a1a2e;
            border-radius: 25px;
            font-size: 0.9rem;
            opacity: 0.5;
            transition: all 0.3s;
        }

        .step.active {
            opacity: 1;
            background: #4ecdc4;
            color: #000;
        }

        .step.done {
            opacity: 1;
            background: #2d5a4a;
        }

        .step-num {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.8rem;
        }

        /* Panels */
        .panel {
            background: #1a1a2e;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .panel h2 {
            font-size: 1rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Video selection */
        .video-select-area {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        select, input[type="text"] {
            padding: 12px 16px;
            background: #0f0f1a;
            border: 2px solid #333;
            border-radius: 8px;
            color: #fff;
            font-size: 1rem;
            min-width: 250px;
        }

        select:focus, input:focus {
            outline: none;
            border-color: #4ecdc4;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #4ecdc4;
            color: #000;
        }

        .btn-primary:hover {
            background: #3dbdb5;
        }

        .btn-danger {
            background: #ff6b6b;
            color: #fff;
        }

        .btn-danger:hover {
            background: #ee5a5a;
        }

        .btn-secondary {
            background: #333;
            color: #fff;
        }

        .btn-secondary:hover {
            background: #444;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 0.85rem;
        }

        .file-upload {
            position: relative;
        }

        .file-upload input[type="file"] {
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        /* Video container - FIXED positioning */
        .video-wrapper {
            position: relative;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 400px;
        }

        .video-container {
            position: relative;
            display: inline-block;
        }

        #videoFrame, #videoStream {
            display: block;
            max-width: 100%;
            max-height: 500px;
        }

        #drawCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        #drawCanvas.drawing {
            pointer-events: auto;
            cursor: crosshair;
        }

        .video-placeholder {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 1.2rem;
        }

        /* Drawing toolbar */
        .draw-toolbar {
            display: flex;
            gap: 10px;
            padding: 15px;
            background: #252540;
            border-radius: 8px;
            margin-top: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .draw-toolbar label {
            color: #888;
            font-size: 0.9rem;
        }

        .draw-instructions {
            background: #4ecdc4;
            color: #000;
            padding: 10px 15px;
            border-radius: 8px;
            font-weight: 500;
            display: none;
        }

        .draw-instructions.visible {
            display: block;
        }

        /* Active streams indicator */
        .active-streams {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .stream-badge {
            background: #2d5a4a;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .stream-badge.current {
            background: #4ecdc4;
            color: #000;
        }

        .stream-badge .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #4ecdc4;
            animation: blink 1s infinite;
        }

        .stream-badge.current .dot {
            background: #000;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Zones list */
        .zones-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
        }

        .zone-card {
            background: #252540;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }

        .zone-name {
            font-weight: 600;
            margin-bottom: 10px;
            color: #4ecdc4;
        }

        .zone-time {
            font-size: 2rem;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            margin: 10px 0;
        }

        .zone-status {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            margin-bottom: 10px;
        }

        .zone-status.occupied {
            background: #ff6b6b;
        }

        .zone-status.empty {
            background: #2d5a4a;
        }

        .zone-delete {
            background: none;
            border: 1px solid #ff6b6b;
            color: #ff6b6b;
            padding: 5px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .zone-delete:hover {
            background: #ff6b6b;
            color: #fff;
        }

        .no-zones {
            text-align: center;
            color: #666;
            padding: 30px;
        }

        /* Controls */
        .controls-row {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        /* Status indicator */
        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
        }

        .status-badge.streaming {
            background: #ff6b6b;
            animation: pulse 1.5s infinite;
        }

        .status-badge.ready {
            background: #2d5a4a;
        }

        .status-badge.drawing {
            background: #f9ca24;
            color: #000;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Hidden elements */
        .hidden { display: none !important; }

        /* Blur toggle button */
        .btn-blur-on {
            background: #9b59b6 !important;
            color: #fff !important;
        }

        .btn-blur-on:hover {
            background: #8e44ad !important;
        }
    </style>
</head>
<body>
    <div class="app">
        <header>
            <h1>Zone Presence Tracker</h1>
        </header>

        <!-- Steps indicator -->
        <div class="steps">
            <div class="step" id="step1">
                <span class="step-num">1</span>
                <span>Choisir video</span>
            </div>
            <div class="step" id="step2">
                <span class="step-num">2</span>
                <span>Dessiner zones</span>
            </div>
            <div class="step" id="step3">
                <span class="step-num">3</span>
                <span>Lancer detection</span>
            </div>
        </div>

        <!-- Step 1: Video selection -->
        <div class="panel">
            <div class="panel-header">
                <h2>Video Source</h2>
                <div class="active-streams" id="activeStreams"></div>
                <span class="status-badge ready" id="statusBadge">
                    <span class="status-dot"></span>
                    <span id="statusText">Pret</span>
                </span>
            </div>
            <div class="video-select-area">
                <select id="videoSelect">
                    <option value="">-- Choisir une video --</option>
                </select>
                <div class="file-upload">
                    <button class="btn btn-secondary">Upload video</button>
                    <input type="file" id="videoUpload" accept="video/*">
                </div>
            </div>
        </div>

        <!-- Video display -->
        <div class="panel">
            <div class="video-wrapper" id="videoWrapper">
                <div class="video-placeholder" id="placeholder">
                    Selectionnez une video pour commencer
                </div>
                <div class="video-container" id="videoContainer">
                    <img id="videoFrame" class="hidden" alt="Video frame">
                    <img id="videoStream" class="hidden" alt="Video stream">
                    <canvas id="drawCanvas" class="hidden"></canvas>
                </div>
            </div>

            <!-- Drawing toolbar -->
            <div class="draw-toolbar" id="drawToolbar">
                <label>Nom de la zone:</label>
                <input type="text" id="zoneName" placeholder="Ex: Zone A" style="min-width: 150px;">
                <button class="btn btn-primary" id="startDrawBtn">Dessiner</button>
                <button class="btn btn-secondary hidden" id="undoBtn">Annuler point</button>
                <button class="btn btn-primary hidden" id="finishBtn">Valider zone</button>
                <button class="btn btn-danger hidden" id="cancelBtn">Annuler</button>
                <div class="draw-instructions" id="drawInstructions">
                    Cliquez sur la video pour placer les points du polygone (min 3 points)
                </div>
            </div>

            <!-- Detection controls -->
            <div class="controls-row">
                <button class="btn btn-primary" id="startDetectionBtn" disabled>Lancer la detection</button>
                <button class="btn btn-danger hidden" id="stopDetectionBtn">Arreter cette video</button>
                <button class="btn btn-danger hidden" id="stopAllBtn">Arreter toutes les videos</button>
                <button class="btn btn-secondary" id="resetTimersBtn">Reset tous les timers</button>
                <button class="btn btn-secondary" id="toggleBlurBtn">Floutage: OFF</button>
            </div>
        </div>

        <!-- Zones panel -->
        <div class="panel">
            <div class="panel-header">
                <h2>Zones & Temps de Presence</h2>
                <button class="btn btn-danger btn-small" id="deleteAllZonesBtn">Supprimer toutes les zones</button>
            </div>
            <div class="zones-grid" id="zonesGrid">
                <div class="no-zones">Aucune zone definie</div>
            </div>
        </div>
    </div>

    <script>
        // State
        let currentVideo = null;
        let isDrawing = false;
        let isCurrentVideoStreaming = false;
        let drawPoints = [];
        let videoWidth = 0;
        let videoHeight = 0;
        let activeVideoStreams = new Set();

        // Elements
        const videoSelect = document.getElementById('videoSelect');
        const videoUpload = document.getElementById('videoUpload');
        const videoFrame = document.getElementById('videoFrame');
        const videoStream = document.getElementById('videoStream');
        const videoContainer = document.getElementById('videoContainer');
        const drawCanvas = document.getElementById('drawCanvas');
        const ctx = drawCanvas.getContext('2d');
        const placeholder = document.getElementById('placeholder');
        const zoneName = document.getElementById('zoneName');
        const startDrawBtn = document.getElementById('startDrawBtn');
        const undoBtn = document.getElementById('undoBtn');
        const finishBtn = document.getElementById('finishBtn');
        const cancelBtn = document.getElementById('cancelBtn');
        const drawInstructions = document.getElementById('drawInstructions');
        const startDetectionBtn = document.getElementById('startDetectionBtn');
        const stopDetectionBtn = document.getElementById('stopDetectionBtn');
        const stopAllBtn = document.getElementById('stopAllBtn');
        const resetTimersBtn = document.getElementById('resetTimersBtn');
        const zonesGrid = document.getElementById('zonesGrid');
        const statusBadge = document.getElementById('statusBadge');
        const statusText = document.getElementById('statusText');
        const activeStreamsDiv = document.getElementById('activeStreams');
        const steps = {
            step1: document.getElementById('step1'),
            step2: document.getElementById('step2'),
            step3: document.getElementById('step3')
        };

        // Initialize
        init();

        async function init() {
            await loadVideos();
            await loadZones();
            await updateActiveStreams();
            updateSteps();

            // Poll zones and streams every second
            setInterval(loadZones, 1000);
            setInterval(updateActiveStreams, 2000);
        }

        async function loadVideos() {
            const res = await fetch('/api/videos');
            const data = await res.json();

            videoSelect.innerHTML = '<option value="">-- Choisir une video --</option>';
            data.videos.forEach(v => {
                videoSelect.innerHTML += `<option value="${v}">${v}</option>`;
            });
        }

        async function updateActiveStreams() {
            try {
                const res = await fetch('/api/streams');
                const data = await res.json();

                activeVideoStreams = new Set(data.streams.map(s => s.video));

                if (data.streams.length === 0) {
                    activeStreamsDiv.innerHTML = '';
                    stopAllBtn.classList.add('hidden');
                } else {
                    activeStreamsDiv.innerHTML = data.streams.map(s =>
                        `<span class="stream-badge ${s.video === currentVideo ? 'current' : ''}">
                            <span class="dot"></span>
                            ${s.video}
                        </span>`
                    ).join('');
                    stopAllBtn.classList.remove('hidden');
                }

                // Update button states
                if (currentVideo) {
                    isCurrentVideoStreaming = activeVideoStreams.has(currentVideo);
                    if (isCurrentVideoStreaming) {
                        startDetectionBtn.classList.add('hidden');
                        stopDetectionBtn.classList.remove('hidden');
                    } else {
                        startDetectionBtn.classList.remove('hidden');
                        stopDetectionBtn.classList.add('hidden');
                    }
                }
            } catch (e) {
                console.error('Error fetching streams:', e);
            }
        }

        async function loadZones() {
            if (!currentVideo) {
                zonesGrid.innerHTML = '<div class="no-zones">Selectionnez une video</div>';
                return;
            }

            const res = await fetch(`/api/presence/${encodeURIComponent(currentVideo)}`);
            const data = await res.json();
            const zones = data.zones;

            if (Object.keys(zones).length === 0) {
                zonesGrid.innerHTML = '<div class="no-zones">Aucune zone definie pour cette video</div>';
                return;
            }

            zonesGrid.innerHTML = '';
            for (const [name, info] of Object.entries(zones)) {
                const statusClass = info.is_occupied ? 'occupied' : 'empty';
                const statusLabel = info.is_occupied ? 'Occupe' : 'Vide';

                zonesGrid.innerHTML += `
                    <div class="zone-card">
                        <div class="zone-name">${name}</div>
                        <div class="zone-status ${statusClass}">${statusLabel}</div>
                        <div class="zone-time">${info.formatted_time}</div>
                        <button class="zone-delete" onclick="deleteZone('${name}')">Supprimer</button>
                    </div>
                `;
            }
        }

        function updateSteps() {
            Object.values(steps).forEach(s => s.classList.remove('active', 'done'));

            if (!currentVideo) {
                steps.step1.classList.add('active');
            } else if (isDrawing) {
                steps.step1.classList.add('done');
                steps.step2.classList.add('active');
            } else if (isCurrentVideoStreaming) {
                steps.step1.classList.add('done');
                steps.step2.classList.add('done');
                steps.step3.classList.add('active');
            } else {
                steps.step1.classList.add('done');
                steps.step2.classList.add('active');
            }
        }

        function updateStatus(status) {
            statusBadge.className = 'status-badge ' + status;
            if (status === 'streaming') {
                statusText.textContent = 'Detection en cours';
            } else if (status === 'drawing') {
                statusText.textContent = 'Mode dessin';
            } else {
                statusText.textContent = 'Pret';
            }
        }

        // Sync canvas size with video
        function syncCanvasSize() {
            const img = videoFrame.classList.contains('hidden') ? videoStream : videoFrame;
            if (!img.naturalWidth) return;

            const displayWidth = img.clientWidth;
            const displayHeight = img.clientHeight;

            drawCanvas.style.width = displayWidth + 'px';
            drawCanvas.style.height = displayHeight + 'px';
        }

        // Video selection
        videoSelect.addEventListener('change', async () => {
            if (!videoSelect.value) return;

            currentVideo = videoSelect.value;

            // Get video info
            const infoRes = await fetch(`/api/videos/${encodeURIComponent(currentVideo)}/info`);
            const info = await infoRes.json();
            videoWidth = info.width;
            videoHeight = info.height;

            // Setup canvas with video dimensions
            drawCanvas.width = videoWidth;
            drawCanvas.height = videoHeight;

            // Check if this video is already streaming
            isCurrentVideoStreaming = activeVideoStreams.has(currentVideo);

            if (isCurrentVideoStreaming) {
                // Show stream
                videoFrame.classList.add('hidden');
                videoStream.classList.remove('hidden');
                videoStream.src = `/api/stream/${encodeURIComponent(currentVideo)}`;
                drawCanvas.classList.add('hidden');
                updateStatus('streaming');
            } else {
                // Show first frame
                videoFrame.src = `/api/videos/${encodeURIComponent(currentVideo)}/frame?t=${Date.now()}`;
                videoFrame.classList.remove('hidden');
                videoStream.classList.add('hidden');
                videoStream.src = '';
                drawCanvas.classList.remove('hidden');
                updateStatus('ready');
            }

            placeholder.classList.add('hidden');
            startDetectionBtn.disabled = false;

            // Wait for image to load then sync canvas
            const img = isCurrentVideoStreaming ? videoStream : videoFrame;
            img.onload = () => {
                syncCanvasSize();
                if (!isCurrentVideoStreaming) {
                    drawExistingZones();
                }
            };

            await updateActiveStreams();
            await loadZones();
            updateSteps();
        });

        // Video upload
        videoUpload.addEventListener('change', async () => {
            if (!videoUpload.files.length) return;

            const formData = new FormData();
            formData.append('file', videoUpload.files[0]);

            await fetch('/api/videos/upload', {
                method: 'POST',
                body: formData
            });

            await loadVideos();
            videoSelect.value = videoUpload.files[0].name;
            videoSelect.dispatchEvent(new Event('change'));
            videoUpload.value = '';
        });

        // Drawing
        startDrawBtn.addEventListener('click', () => {
            if (!zoneName.value.trim()) {
                alert('Entrez un nom de zone');
                zoneName.focus();
                return;
            }
            if (!currentVideo) {
                alert('Selectionnez d\'abord une video');
                return;
            }
            if (isCurrentVideoStreaming) {
                alert('Arretez la detection avant de dessiner');
                return;
            }

            isDrawing = true;
            drawPoints = [];

            startDrawBtn.classList.add('hidden');
            undoBtn.classList.remove('hidden');
            finishBtn.classList.remove('hidden');
            cancelBtn.classList.remove('hidden');
            drawInstructions.classList.add('visible');
            zoneName.disabled = true;

            drawCanvas.classList.add('drawing');
            updateSteps();
            updateStatus('drawing');
        });

        drawCanvas.addEventListener('click', (e) => {
            if (!isDrawing) return;

            const rect = drawCanvas.getBoundingClientRect();
            const scaleX = drawCanvas.width / rect.width;
            const scaleY = drawCanvas.height / rect.height;

            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            drawPoints.push([x, y]);
            redrawCanvas();
        });

        undoBtn.addEventListener('click', () => {
            if (drawPoints.length > 0) {
                drawPoints.pop();
                redrawCanvas();
            }
        });

        finishBtn.addEventListener('click', async () => {
            if (drawPoints.length < 3) {
                alert('Il faut au moins 3 points pour creer une zone');
                return;
            }

            await fetch('/api/zones', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    name: zoneName.value.trim(),
                    polygons: [drawPoints],
                    video: currentVideo
                })
            });

            exitDrawingMode();
            await loadZones();
            drawExistingZones();
        });

        cancelBtn.addEventListener('click', () => {
            exitDrawingMode();
            drawExistingZones();
        });

        function exitDrawingMode() {
            isDrawing = false;
            drawPoints = [];
            zoneName.value = '';
            zoneName.disabled = false;

            startDrawBtn.classList.remove('hidden');
            undoBtn.classList.add('hidden');
            finishBtn.classList.add('hidden');
            cancelBtn.classList.add('hidden');
            drawInstructions.classList.remove('visible');

            drawCanvas.classList.remove('drawing');
            updateSteps();
            updateStatus('ready');
        }

        function redrawCanvas() {
            ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);

            // Draw existing zones first (but don't fetch, use cached)
            drawExistingZonesSync();

            // Draw current polygon
            if (drawPoints.length > 0) {
                ctx.beginPath();
                ctx.moveTo(drawPoints[0][0], drawPoints[0][1]);

                for (let i = 1; i < drawPoints.length; i++) {
                    ctx.lineTo(drawPoints[i][0], drawPoints[i][1]);
                }

                if (drawPoints.length >= 3) {
                    ctx.closePath();
                    ctx.fillStyle = 'rgba(78, 205, 196, 0.3)';
                    ctx.fill();
                }

                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 3;
                ctx.stroke();

                // Draw points
                drawPoints.forEach((p, i) => {
                    ctx.beginPath();
                    ctx.arc(p[0], p[1], 6, 0, Math.PI * 2);
                    ctx.fillStyle = i === 0 ? '#2ed573' : '#4ecdc4';
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
            }
        }

        let cachedZones = {};

        async function drawExistingZones() {
            if (!currentVideo) return;

            const res = await fetch(`/api/zones/${encodeURIComponent(currentVideo)}`);
            const data = await res.json();
            cachedZones = data.zones;

            drawExistingZonesSync();
        }

        function drawExistingZonesSync() {
            if (isDrawing) return;

            ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);

            for (const [name, zone] of Object.entries(cachedZones)) {
                for (const polygon of zone.polygons) {
                    if (polygon.length < 3) continue;

                    ctx.beginPath();
                    ctx.moveTo(polygon[0][0], polygon[0][1]);
                    for (let i = 1; i < polygon.length; i++) {
                        ctx.lineTo(polygon[i][0], polygon[i][1]);
                    }
                    ctx.closePath();

                    ctx.fillStyle = 'rgba(255, 165, 0, 0.2)';
                    ctx.fill();
                    ctx.strokeStyle = '#ffa500';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Zone label
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 14px system-ui';
                    ctx.fillText(name, polygon[0][0] + 5, polygon[0][1] - 8);
                }
            }
        }

        // Detection
        startDetectionBtn.addEventListener('click', async () => {
            if (!currentVideo) return;

            isCurrentVideoStreaming = true;
            activeVideoStreams.add(currentVideo);

            // Hide frame, show stream
            videoFrame.classList.add('hidden');
            videoStream.classList.remove('hidden');
            drawCanvas.classList.add('hidden');

            videoStream.src = `/api/stream/${encodeURIComponent(currentVideo)}`;

            startDetectionBtn.classList.add('hidden');
            stopDetectionBtn.classList.remove('hidden');

            updateSteps();
            updateStatus('streaming');
            await updateActiveStreams();
        });

        stopDetectionBtn.addEventListener('click', async () => {
            if (!currentVideo) return;

            await fetch(`/api/stream/${encodeURIComponent(currentVideo)}/stop`, { method: 'POST' });

            isCurrentVideoStreaming = false;
            activeVideoStreams.delete(currentVideo);

            // Show frame again
            videoStream.src = '';
            videoStream.classList.add('hidden');
            videoFrame.src = `/api/videos/${encodeURIComponent(currentVideo)}/frame?t=${Date.now()}`;
            videoFrame.classList.remove('hidden');
            drawCanvas.classList.remove('hidden');

            startDetectionBtn.classList.remove('hidden');
            stopDetectionBtn.classList.add('hidden');

            updateSteps();
            updateStatus('ready');
            await updateActiveStreams();

            videoFrame.onload = () => {
                syncCanvasSize();
                drawExistingZones();
            };
        });

        stopAllBtn.addEventListener('click', async () => {
            await fetch('/api/streams/stop', { method: 'POST' });

            isCurrentVideoStreaming = false;
            activeVideoStreams.clear();

            if (currentVideo) {
                videoStream.src = '';
                videoStream.classList.add('hidden');
                videoFrame.src = `/api/videos/${encodeURIComponent(currentVideo)}/frame?t=${Date.now()}`;
                videoFrame.classList.remove('hidden');
                drawCanvas.classList.remove('hidden');

                videoFrame.onload = () => {
                    syncCanvasSize();
                    drawExistingZones();
                };
            }

            startDetectionBtn.classList.remove('hidden');
            stopDetectionBtn.classList.add('hidden');

            updateSteps();
            updateStatus('ready');
            await updateActiveStreams();
        });

        resetTimersBtn.addEventListener('click', async () => {
            if (!confirm('Remettre tous les timers a zero ?')) return;
            await fetch('/api/zones/reset', { method: 'POST' });
            await loadZones();
        });

        // Blur toggle
        const toggleBlurBtn = document.getElementById('toggleBlurBtn');

        async function updateBlurButton() {
            const res = await fetch('/api/blur');
            const data = await res.json();
            if (data.enabled) {
                toggleBlurBtn.textContent = 'Floutage: ON';
                toggleBlurBtn.classList.add('btn-blur-on');
            } else {
                toggleBlurBtn.textContent = 'Floutage: OFF';
                toggleBlurBtn.classList.remove('btn-blur-on');
            }
        }

        toggleBlurBtn.addEventListener('click', async () => {
            await fetch('/api/blur/toggle', { method: 'POST' });
            await updateBlurButton();
        });

        // Initialize blur state
        updateBlurButton();

        async function deleteZone(name) {
            if (!confirm(`Supprimer la zone "${name}" de cette video ?`)) return;
            await fetch(`/api/zones/${encodeURIComponent(currentVideo)}/${encodeURIComponent(name)}`, { method: 'DELETE' });
            await loadZones();
            drawExistingZones();
        }

        // Delete all zones for current video
        document.getElementById('deleteAllZonesBtn').addEventListener('click', async () => {
            if (!currentVideo) return;
            if (!confirm('Supprimer TOUTES les zones de cette video ?')) return;
            await fetch(`/api/zones/${encodeURIComponent(currentVideo)}`, { method: 'DELETE' });
            await loadZones();
            drawExistingZones();
        });

        // Handle window resize
        window.addEventListener('resize', syncCanvasSize);
    </script>
</body>
</html>
