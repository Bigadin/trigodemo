<!DOCTYPE html>
<html lang="fr" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YRYS - Zone Presence Tracker</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* ========================================
           YRYS Design System Tokens
           ======================================== */
        :root {
            /* Typography */
            --font-sans: "Manrope", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;

            /* Spacing scale */
            --space-1: 4px;
            --space-2: 8px;
            --space-3: 12px;
            --space-4: 16px;
            --space-5: 24px;
            --space-6: 32px;
            --space-7: 48px;

            /* Radius (un peu plus carré) */
            --radius-sm: 6px;
            --radius-md: 10px;
            --radius-lg: 12px;
            --radius-xl: 14px;

            /* Brand accents */
            --brand-01: #F08321; /* Orange */
            --brand-02: #10B0F9; /* Cyan */
            --brand-03: #062DB6; /* Blue */
            --brand-04: #BD44D5; /* Purple */

            /* Grays */
            --gray-01: #EDEFF7; /* Cloud */
            --gray-02: #D3D6E0; /* Smoke */
            --gray-03: #BCBFCC; /* Steel */
            --gray-04: #9DA2B3; /* Space */
            --gray-05: #6E7180; /* Graphite */
            --gray-06: #40424D; /* Arsenic */
            --gray-07: #1E1E24; /* Phantom */
            --gray-08: #000000; /* Black */

            /* Type scale */
            --text-xs: 12px;
            --text-sm: 14px;
            --text-md: 16px;
            --text-lg: 18px;
            --text-xl: 24px;
            --text-2xl: 32px;
        }

        /* Dark theme (default) */
        :root[data-theme="dark"] {
            --color-bg: #0B0F14;
            --color-surface: #111825;
            --color-surface-2: #0E141F;
            --color-surface-3: #1a2332;
            --color-border: rgba(255, 255, 255, 0.08);
            --color-border-hover: rgba(255, 255, 255, 0.15);

            --color-text: #F5F7FF;
            --color-text-muted: rgba(245, 247, 255, 0.65);
            --color-text-subtle: rgba(245, 247, 255, 0.4);

            --color-primary: var(--brand-02);
            --color-primary-hover: #0ea5e9;
            --color-primary-pressed: #0284c7;

            --color-success: #22c55e;
            --color-danger: #ef4444;
            --color-warning: var(--brand-01);

            --color-focus: var(--brand-02);

            --bg-texture-opacity: 0.10;
        }

        /* Light theme (par défaut) — gris clairs, pas “blanc pur” */
        :root[data-theme="light"] {
            --color-bg: #E7EBF2;
            --color-surface: #EEF2F8;
            --color-surface-2: #F6F8FC;
            --color-surface-3: #E3E9F3;
            --color-border: rgba(15, 23, 42, 0.12);
            --color-border-hover: rgba(15, 23, 42, 0.18);

            --color-text: #0F172A;
            --color-text-muted: rgba(15, 23, 42, 0.65);
            --color-text-subtle: rgba(15, 23, 42, 0.45);

            --color-primary: var(--brand-02);
            --color-primary-hover: #0ea5e9;
            --color-primary-pressed: #0284c7;

            --color-success: #16a34a;
            --color-danger: #dc2626;
            --color-warning: var(--brand-01);

            --color-focus: var(--brand-02);

            --bg-texture-opacity: 0.18;
        }

        /* Sidebar reste sombre même en light */
        :root {
            --sidebar-bg: #0B0F14;
            --sidebar-surface: #111825;
            --sidebar-surface-2: #0E141F;
            --sidebar-border: rgba(255, 255, 255, 0.08);
            --sidebar-border-hover: rgba(255, 255, 255, 0.14);
            --sidebar-text: #F5F7FF;
            --sidebar-text-muted: rgba(245, 247, 255, 0.68);
            --sidebar-text-subtle: rgba(245, 247, 255, 0.45);
        }

        /* ========================================
           Base Reset & Typography
           ======================================== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-sans);
            background: var(--color-bg);
            color: var(--color-text);
            min-height: 100vh;
            font-size: var(--text-md);
            line-height: 1.5;
        }

        /* Texture background (Light Texture YRYS) */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 360px;
            background-image: url("/static/assets_youn/YrysUIPackage/UI_Jatin/Light%20Texture.png");
            background-size: 720px auto;
            background-position: top center;
            background-repeat: repeat-x;
            opacity: var(--bg-texture-opacity);
            mask-image: linear-gradient(to bottom, rgba(0,0,0,1) 0%, rgba(0,0,0,0.75) 45%, rgba(0,0,0,0) 100%);
            pointer-events: none;
            z-index: 0;
        }

        /* Texture band bottom */
        body::after {
            content: '';
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 260px;
            background-image: url("/static/assets_youn/YrysUIPackage/UI_Jatin/Light%20Texture.png");
            background-size: 720px auto;
            background-position: bottom center;
            background-repeat: repeat-x;
            opacity: calc(var(--bg-texture-opacity) * 0.85);
            mask-image: linear-gradient(to top, rgba(0,0,0,1) 0%, rgba(0,0,0,0.65) 45%, rgba(0,0,0,0) 100%);
            pointer-events: none;
            z-index: 0;
        }

        /* ========================================
           App Layout
           ======================================== */
        .app-layout {
            display: flex;
            min-height: 100vh;
            position: relative;
            z-index: 1;
        }

        /* Sidebar */
        .sidebar {
            width: 260px;
            background: var(--sidebar-surface);
            border-right: 1px solid var(--sidebar-border);
            display: flex;
            flex-direction: column;
            position: fixed;
            height: 100vh;
            overflow-y: auto;
        }

        .sidebar-header {
            padding: var(--space-5);
            border-bottom: 1px solid var(--sidebar-border);
            display: flex;
            align-items: center;
            gap: var(--space-3);
        }

        .logo {
            width: 36px;
            height: 36px;
        }

        .logo-text {
            font-size: var(--text-lg);
            font-weight: 700;
            color: var(--sidebar-text);
            letter-spacing: 0.5px;
        }

        .sidebar-section {
            padding: var(--space-4);
        }

        .sidebar-label {
            font-size: var(--text-xs);
            font-weight: 600;
            color: var(--sidebar-text-subtle);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: var(--space-3);
        }

        .sidebar-nav {
            display: flex;
            flex-direction: column;
            gap: var(--space-1);
        }

        .nav-item {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-3) var(--space-4);
            border-radius: var(--radius-md);
            color: var(--sidebar-text-muted);
            text-decoration: none;
            font-weight: 500;
            font-size: var(--text-sm);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .nav-item:hover {
            background: rgba(255, 255, 255, 0.06);
            color: var(--sidebar-text);
        }

        .nav-item.active {
            background: rgba(255, 255, 255, 0.08);
            color: var(--sidebar-text);
        }

        .nav-icon {
            width: 20px;
            height: 20px;
            opacity: 0.7;
        }

        .nav-icon-img {
            width: 20px;
            height: 20px;
            opacity: 0.7;
            display: inline-block;
            flex: 0 0 auto;
            filter: invert(1);
        }

        .nav-item.active .nav-icon,
        .nav-item:hover .nav-icon {
            opacity: 1;
        }

        .nav-item.active .nav-icon-img,
        .nav-item:hover .nav-icon-img {
            opacity: 1;
        }

        /* Zone list in sidebar */
        .zone-list-sidebar {
            display: flex;
            flex-direction: column;
            gap: var(--space-2);
            margin-top: var(--space-2);
        }

        .zone-item-sidebar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--space-3);
            background: var(--sidebar-surface-2);
            border-radius: var(--radius-sm);
            border: 1px solid var(--sidebar-border);
        }

        .zone-item-info {
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }

        .zone-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--color-success);
        }

        .zone-dot.occupied {
            background: var(--color-danger);
            animation: pulse-dot 1.5s infinite;
        }

        @keyframes pulse-dot {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .zone-item-name {
            font-size: var(--text-sm);
            font-weight: 500;
        }

        .zone-item-time {
            font-size: var(--text-xs);
            font-family: 'Courier New', monospace;
            color: var(--brand-02);
            font-weight: 600;
        }

        /* Sidebar lisibilité */
        .sidebar * {
            text-shadow: 0 1px 0 rgba(0,0,0,0.35);
        }

        .sidebar a, .sidebar .nav-item, .sidebar .zone-item-name {
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Sidebar footer */
        .sidebar-footer {
            margin-top: auto;
            padding: var(--space-4);
            border-top: 1px solid var(--sidebar-border);
        }

        .version-badge {
            font-size: var(--text-xs);
            color: var(--sidebar-text-subtle);
        }

        /* Main content */
        .main-content {
            flex: 1;
            margin-left: 260px;
            padding: var(--space-6);
            display: flex;
            flex-direction: column;
            gap: var(--space-5);
        }

        /* Header bar */
        .header-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .page-title {
            font-size: var(--text-xl);
            font-weight: 600;
        }

        .page-subtitle {
            font-size: var(--text-sm);
            color: var(--color-text-muted);
            margin-top: var(--space-1);
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: var(--space-3);
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-2) var(--space-4);
            border-radius: var(--radius-lg);
            font-size: var(--text-sm);
            font-weight: 500;
        }

        .status-indicator.ready {
            background: rgba(34, 197, 94, 0.15);
            color: var(--color-success);
        }

        .status-indicator.streaming {
            background: rgba(239, 68, 68, 0.15);
            color: var(--color-danger);
            animation: pulse-status 1.5s infinite;
        }

        .status-indicator.drawing {
            background: rgba(240, 131, 33, 0.15);
            color: var(--brand-01);
        }

        @keyframes pulse-status {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .status-dot-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
        }

        /* Cards */
        .card {
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-lg);
            padding: var(--space-5);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-4);
        }

        .card-title {
            font-size: var(--text-md);
            font-weight: 600;
            color: var(--color-text);
        }

        .card-subtitle {
            font-size: var(--text-xs);
            color: var(--color-text-subtle);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Video section */
        .video-section {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: var(--space-5);
        }

        @media (max-width: 1200px) {
            .video-section {
                grid-template-columns: 1fr;
            }
        }

        .video-card {
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-lg);
            overflow: hidden;
        }

        .video-card-header {
            padding: var(--space-4) var(--space-5);
            border-bottom: 1px solid var(--color-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .video-title {
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }

        .video-status {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            font-size: var(--text-sm);
            color: var(--color-success);
        }

        .video-status.offline {
            color: var(--color-text-muted);
        }

        .video-wrapper {
            position: relative;
            background: #000;
            aspect-ratio: 16/9;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .video-fab {
            position: absolute;
            right: 14px;
            bottom: 14px;
            width: 44px;
            height: 44px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.16);
            background: rgba(17, 24, 37, 0.65);
            color: #fff;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 5;
            backdrop-filter: blur(6px);
        }

        .video-fab:hover {
            background: rgba(17, 24, 37, 0.78);
        }

        .video-fab img {
            width: 20px;
            height: 20px;
            filter: invert(1);
            opacity: 0.92;
        }

        /* Le panneau "drawPanel" reste interne (on déclenche via l'éditeur modal). */

        .video-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #videoFrame, #videoStream {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        #drawCanvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #drawCanvas.drawing {
            pointer-events: auto;
            cursor: crosshair;
        }

        .video-placeholder {
            color: var(--color-text-subtle);
            font-size: var(--text-md);
            text-align: center;
            padding: var(--space-6);
        }

        .video-placeholder-icon {
            font-size: 48px;
            margin-bottom: var(--space-3);
            opacity: 0.3;
        }

        /* Video controls toolbar */
        .video-toolbar {
            padding: var(--space-4) var(--space-5);
            border-top: 1px solid var(--color-border);
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-3);
            align-items: center;
        }

        /* Camera status panel */
        .camera-panel {
            display: flex;
            flex-direction: column;
            gap: var(--space-4);
        }

        .camera-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-3);
        }

        .camera-item {
            background: var(--color-surface-2);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            padding: var(--space-3);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .camera-item:hover {
            border-color: var(--color-border-hover);
            background: var(--color-surface-3);
        }

        .camera-item.active {
            border-color: var(--color-primary);
            background: rgba(16, 176, 249, 0.08);
        }

        .camera-item-name {
            font-size: var(--text-sm);
            font-weight: 500;
            margin-bottom: var(--space-1);
        }

        .camera-item-status {
            font-size: var(--text-xs);
            display: flex;
            align-items: center;
            gap: var(--space-1);
        }

        .camera-item-status.online {
            color: var(--color-success);
        }

        .camera-item-status.offline {
            color: var(--color-text-subtle);
        }

        /* Forms */
        .form-group {
            display: flex;
            flex-direction: column;
            gap: var(--space-2);
        }

        .form-label {
            font-size: var(--text-sm);
            font-weight: 500;
            color: var(--color-text-muted);
        }

        .form-row {
            display: flex;
            gap: var(--space-3);
            align-items: flex-end;
        }

        select, input[type="text"] {
            padding: var(--space-3) var(--space-4);
            background: var(--color-surface-2);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            color: var(--color-text);
            font-family: var(--font-sans);
            font-size: var(--text-sm);
            min-width: 200px;
            transition: all 0.2s ease;
        }

        select:hover, input[type="text"]:hover {
            border-color: var(--color-border-hover);
        }

        select:focus, input[type="text"]:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: 0 0 0 3px rgba(16, 176, 249, 0.15);
        }

        select:disabled, input:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Buttons */
        .btn {
            padding: var(--space-3) var(--space-4);
            border: none;
            border-radius: var(--radius-md);
            font-family: var(--font-sans);
            font-size: var(--text-sm);
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: var(--space-2);
            white-space: nowrap;
        }

        .btn:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(16, 176, 249, 0.3);
        }

        .btn-primary {
            background: var(--color-primary);
            color: #000;
        }

        .btn-primary:hover {
            background: var(--color-primary-hover);
        }

        .btn-primary:active {
            background: var(--color-primary-pressed);
        }

        .btn-secondary {
            background: var(--color-surface-3);
            color: var(--color-text);
            border: 1px solid var(--color-border);
        }

        .btn-secondary:hover {
            background: var(--gray-06);
            border-color: var(--color-border-hover);
        }

        .btn-danger {
            background: rgba(239, 68, 68, 0.15);
            color: var(--color-danger);
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .btn-danger:hover {
            background: rgba(239, 68, 68, 0.25);
        }

        .btn-ghost {
            background: transparent;
            color: var(--color-text-muted);
        }

        .btn-ghost:hover {
            background: var(--color-surface-3);
            color: var(--color-text);
        }

        .btn-icon {
            padding: var(--space-2);
            min-width: 36px;
            justify-content: center;
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            pointer-events: none;
        }

        .btn-blur-on {
            background: rgba(189, 68, 213, 0.2) !important;
            color: var(--brand-04) !important;
            border-color: rgba(189, 68, 213, 0.3) !important;
        }

        /* Zones grid */
        .zones-section {
            margin-top: var(--space-4);
        }

        .zones-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: var(--space-4);
        }

        .zone-card {
            background: var(--color-surface-2);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            padding: var(--space-4);
            transition: all 0.2s ease;
        }

        .zone-card:hover {
            border-color: var(--color-border-hover);
        }

        .zone-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: var(--space-3);
        }

        .zone-card-name {
            font-weight: 600;
            font-size: var(--text-md);
            color: var(--color-primary);
        }

        .zone-card-status {
            padding: var(--space-1) var(--space-3);
            border-radius: var(--radius-lg);
            font-size: var(--text-xs);
            font-weight: 500;
        }

        .zone-card-status.occupied {
            background: rgba(239, 68, 68, 0.15);
            color: var(--color-danger);
        }

        .zone-card-status.empty {
            background: rgba(34, 197, 94, 0.15);
            color: var(--color-success);
        }

        .zone-card-time {
            font-size: var(--text-2xl);
            font-family: 'Courier New', monospace;
            font-weight: 700;
            margin: var(--space-3) 0;
            color: var(--color-text);
        }

        .zone-card-actions {
            display: flex;
            gap: var(--space-2);
        }

        /* =========================================================
           Occupation / Absence (style "pro" inspiré Win98)
           ========================================================= */
        .zone-name-pill {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            border-radius: 6px;
            background: #0F172A;
            color: #F8FAFC;
            font-weight: 800;
            font-size: var(--text-sm);
            letter-spacing: 0.2px;
        }

        .zone-forms-count {
            margin-top: 8px;
            font-size: var(--text-xs);
            color: var(--color-text-muted);
        }

        .occ-bars {
            margin-top: var(--space-4);
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .occ-head {
            display: flex;
            align-items: baseline;
            justify-content: space-between;
            gap: 10px;
            font-size: var(--text-xs);
            color: var(--color-text-muted);
        }

        .occ-head strong {
            color: var(--color-text);
            font-weight: 800;
        }

        .occ-head .pct {
            font-family: 'Courier New', monospace;
            font-weight: 800;
            color: var(--color-text);
        }

        .occ-head .secs {
            font-family: 'Courier New', monospace;
            font-weight: 700;
            color: var(--color-text-muted);
            white-space: nowrap;
        }

        .occ-track {
            width: 100%;
            height: 14px;
            border-radius: 4px;
            background: rgba(15, 23, 42, 0.10);
            border: 1px solid rgba(15, 23, 42, 0.30);
            box-shadow:
                inset 1px 1px 0 rgba(255,255,255,0.85),
                inset -1px -1px 0 rgba(15,23,42,0.18);
            overflow: hidden;
        }

        .occ-fill {
            height: 100%;
            width: 0%;
            background: rgba(16,176,249,0.95); /* bleu */
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.25);
        }

        .occ-fill.red {
            background: rgba(127, 29, 29, 0.92); /* rouge foncé */
        }

        :root[data-theme="dark"] .occ-track {
            background: rgba(255,255,255,0.06);
            border-color: rgba(255,255,255,0.14);
            box-shadow:
                inset 1px 1px 0 rgba(255,255,255,0.10),
                inset -1px -1px 0 rgba(0,0,0,0.35);
        }

        .no-zones {
            grid-column: 1 / -1;
            text-align: center;
            color: var(--color-text-subtle);
            padding: var(--space-7);
            background: var(--color-surface-2);
            border-radius: var(--radius-md);
            border: 1px dashed var(--color-border);
        }

        /* Drawing instructions */
        .draw-instructions {
            background: rgba(240, 131, 33, 0.15);
            color: var(--brand-01);
            padding: var(--space-3) var(--space-4);
            border-radius: var(--radius-md);
            font-weight: 500;
            font-size: var(--text-sm);
            display: none;
        }

        .draw-instructions.visible {
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }

        .btn-small {
            padding: var(--space-2) var(--space-3);
            font-size: var(--text-xs);
        }

        /* Drawing HUD (dans la vidéo) */
        .draw-hud {
            position: absolute;
            left: var(--space-4);
            right: var(--space-4);
            bottom: var(--space-4);
            display: flex;
            justify-content: space-between;
            gap: var(--space-4);
            padding: var(--space-4);
            border-radius: var(--radius-lg);
            background: rgba(0, 0, 0, 0.45);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.12);
            z-index: 5;
        }

        :root[data-theme="light"] .draw-hud {
            background: rgba(255, 255, 255, 0.65);
            border: 1px solid rgba(15, 23, 42, 0.12);
        }

        .draw-hud-left {
            display: flex;
            flex-direction: column;
            gap: var(--space-2);
            min-width: 0;
        }

        .draw-hud-title {
            font-weight: 700;
            font-size: var(--text-sm);
            color: var(--color-text);
        }

        .draw-hud-actions {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        /* Draw panel (remplace le modal) */
        .draw-panel {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-3);
            align-items: flex-end;
            padding: var(--space-3);
            border-radius: var(--radius-md);
            background: var(--color-surface-2);
            border: 1px solid var(--color-border);
        }

        .draw-panel .form-group {
            min-width: 180px;
        }

        .segmented {
            display: inline-flex;
            gap: 0;
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            overflow: hidden;
            background: var(--color-surface);
        }

        .segmented .btn {
            border-radius: 0;
            border: 0;
        }

        .segmented .btn.active {
            background: rgba(16, 176, 249, 0.16);
            color: var(--color-text);
        }

        .draw-tree {
            display: flex;
            flex-direction: column;
            gap: var(--space-2);
        }

        .tree-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: var(--space-2);
            padding: var(--space-2) var(--space-3);
            border-radius: var(--radius-sm);
            cursor: pointer;
            border: 1px solid transparent;
            position: relative;
        }

        .tree-row:hover {
            background: rgba(255, 255, 255, 0.06);
            border-color: var(--sidebar-border-hover);
        }

        .tree-row .left {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            min-width: 0;
        }

        .tree-row .label {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            color: var(--sidebar-text);
            font-size: var(--text-sm);
            font-weight: 500;
        }

        .tree-row .meta {
            font-family: 'Courier New', monospace;
            font-size: var(--text-xs);
            color: var(--brand-02);
            font-weight: 700;
        }

        .tree-children {
            margin-left: 18px;
            padding-left: 12px;
            display: flex;
            flex-direction: column;
            gap: var(--space-1);
            border-left: 1px solid rgba(255,255,255,0.22); /* repère hiérarchie */
        }

        .tree-children .tree-row::before {
            content: "";
            position: absolute;
            left: -12px;
            top: 50%;
            width: 10px;
            height: 1px;
            background: rgba(255,255,255,0.22); /* petite branche */
            transform: translateY(-50%);
        }

        .tree-leaf .label {
            color: var(--sidebar-text-muted);
            font-size: var(--text-xs);
        }

        /* Zone cards: previews + selection */
        .zone-previews {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: var(--space-2);
        }
        .zone-preview-box {
            width: 92px;
            height: 58px;
            border-radius: var(--radius-sm);
            overflow: hidden;
            border: 1px solid var(--color-border);
            background: rgba(0,0,0,0.02);
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 0 0 auto;
        }
        .zone-preview-box svg { display:block; width:100%; height:100%; }
        .zone-preview-box.active {
            outline: 2px solid rgba(16,176,249,0.85);
            outline-offset: 2px;
            border-color: rgba(16,176,249,0.55);
        }
        .zone-card.selected {
            border-color: rgba(16,176,249,0.55);
            box-shadow: 0 0 0 3px rgba(16,176,249,0.15);
        }

        /* LOV selects (dropdown) — give room for arrow and consistent padding */
        .lov-select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            padding-right: 38px !important; /* space for arrow */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='14' height='14' viewBox='0 0 24 24'%3E%3Cpath d='M7 10l5 5 5-5' fill='none' stroke='%23aab0c6' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center; /* margin-right for arrow */
            background-size: 14px 14px;
        }
        .lov-select:focus { outline: none; }

        /* Line zones (counting line) — activity UI */
        .line-metrics {
            margin-top: var(--space-3);
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-2);
            font-family: 'Courier New', monospace;
            font-size: var(--text-xs);
            color: var(--color-text);
            opacity: 0.95;
        }
        .line-metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            border: 1px solid var(--color-border);
            border-radius: var(--radius-sm);
            background: rgba(255,255,255,0.03);
        }
        .line-spark {
            margin-top: var(--space-2);
            height: 26px;
            border: 1px solid var(--color-border);
            border-radius: var(--radius-sm);
            background: rgba(0,0,0,0.02);
            overflow: hidden;
        }
        .line-spark svg { width: 100%; height: 100%; display: block; }
        .line-spark .base { stroke: rgba(255,255,255,0.18); stroke-width: 1; }
        .line-spark .wave { stroke: #10B0F9; stroke-width: 2; fill: none; }

        /* =========================================================
           Drawing Editor (modal) — “paint-like”
           ========================================================= */
        .editor-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.55);
            z-index: 300;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: var(--space-6);
        }

        .editor {
            width: min(1240px, 100%);
            height: min(820px, 100%);
            border-radius: 14px;
            overflow: hidden;
            background: #1B1E27;
            border: 1px solid rgba(255,255,255,0.10);
            box-shadow: 0 35px 120px rgba(0,0,0,0.45);
            display: flex;
            flex-direction: column;
        }

        .editor-topbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 18px;
            background: #232734;
            border-bottom: 1px solid rgba(255,255,255,0.08);
        }

        .editor-title {
            font-weight: 700;
            color: #F5F7FF;
        }

        .editor-subtitle {
            font-size: var(--text-xs);
            color: rgba(245,247,255,0.65);
            margin-top: 2px;
        }

        .editor-body {
            flex: 1;
            display: grid;
            grid-template-columns: 1.6fr 0.9fr;
            gap: 16px;
            padding: 16px;
            min-height: 0;
        }

        .editor-left {
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-height: 0;
        }

        .editor-canvas-wrap {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            background: #0b0f14;
            border: 1px solid rgba(255,255,255,0.10);
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 0;
        }

        .editor-hoverbar {
            position: absolute;
            z-index: 3;
            display: flex;
            gap: 6px;
            padding: 6px;
            border-radius: 12px;
            background: rgba(35,39,52,0.92);
            border: 1px solid rgba(255,255,255,0.12);
            backdrop-filter: blur(10px);
            box-shadow: 0 14px 50px rgba(0,0,0,0.35);
            pointer-events: auto; /* hoverbar cliquable */
        }

        .editor-hoverbtn {
            width: 34px;
            height: 34px;
            padding: 0;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.12);
            background: rgba(255,255,255,0.06);
            color: #F5F7FF;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
        }

        .editor-hoverbtn {
            pointer-events: auto; /* seuls les boutons capturent le clic */
        }

        .editor-hoverbtn:hover { background: rgba(16,176,249,0.14); border-color: rgba(16,176,249,0.35); }
        .editor-hoverbtn.danger:hover { background: rgba(239,68,68,0.18); border-color: rgba(239,68,68,0.35); }
        .editor-hoverbtn span { display: none; }

        .editor-canvas-wrap img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            display: block;
        }

        #editorCanvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            touch-action: none; /* drag plus réactif (pas de gesture/scroll) */
        }

        .editor-right {
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-height: 0;
            overflow: auto;
        }

        .editor-card {
            background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 12px;
            padding: 14px;
        }

        .editor-card h3 {
            font-size: var(--text-sm);
            font-weight: 700;
            color: #F5F7FF;
            margin-bottom: 10px;
        }

        .editor-kv {
            display: grid;
            grid-template-columns: 70px 1fr;
            gap: 8px 10px;
            font-size: var(--text-sm);
            color: rgba(245,247,255,0.78);
        }

        .editor-kv .k { color: rgba(245,247,255,0.55); }

        .editor-zones {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: 220px;
            overflow: auto;
        }

        .editor-zone-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            padding: 10px 10px;
            border-radius: 10px;
            cursor: pointer;
            border: 1px solid transparent;
            background: rgba(255,255,255,0.03);
        }

        .editor-zone-row:hover { border-color: rgba(16,176,249,0.35); }
        .editor-zone-row.active { border-color: rgba(16,176,249,0.65); background: rgba(16,176,249,0.10); }

        .editor-zone-left {
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 0;
        }

        .editor-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #22c55e;
        }

        .editor-zone-name {
            color: #F5F7FF;
            font-weight: 600;
            font-size: var(--text-sm);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .editor-zone-meta {
            color: rgba(245,247,255,0.65);
            font-family: 'Courier New', monospace;
            font-size: var(--text-xs);
            white-space: nowrap;
        }

        .editor-tools {
            background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 12px;
            padding: 12px;
        }

        .tool-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        .tool-btn {
            padding: 12px 14px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.10);
            background: rgba(255,255,255,0.06);
            color: #F5F7FF;
            font-weight: 700;
            font-size: var(--text-sm);
            cursor: pointer;
        }

        .tool-btn.icon {
            padding: 10px 12px;
            min-width: 108px;
            height: 44px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .tool-ico {
            width: 20px;
            height: 20px;
            display: block;
            opacity: 0.95;
            filter: brightness(1.15);
        }

        .tool-label {
            font-weight: 700;
            font-size: var(--text-xs);
            color: rgba(245,247,255,0.92);
            letter-spacing: 0.2px;
            white-space: nowrap;
        }

        .tool-btn.primary { background: rgba(16,176,249,0.20); border-color: rgba(16,176,249,0.35); }
        .tool-btn.green { background: rgba(34,197,94,0.18); border-color: rgba(34,197,94,0.35); }
        .tool-btn.yellow { background: rgba(240,131,33,0.18); border-color: rgba(240,131,33,0.35); }
        .tool-btn.red { background: rgba(239,68,68,0.18); border-color: rgba(239,68,68,0.35); }
        .tool-btn.active { outline: 2px solid rgba(16,176,249,0.55); }

        /* Fix contraste croix fermeture (noir sur noir) */
        #editorCloseBtn { color: #F5F7FF; }

        .editor-guide {
            margin-top: 12px;
            padding: 10px 12px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.10);
            background: rgba(0,0,0,0.22);
            color: rgba(245,247,255,0.75);
            font-size: var(--text-sm);
            line-height: 1.35;
            /* Stabilise la mise en page: évite que 1 ligne vs 2 lignes fasse "trembler" le modal */
            min-height: 54px;
            display: flex;
            align-items: center;
        }

        .editor-bottombar {
            padding: 14px 16px;
            background: #232734;
            border-top: 1px solid rgba(255,255,255,0.08);
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 12px;
        }

        .editor-save-main.btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 14px 18px;
            font-weight: 700;
            min-width: 260px;
        }

        /* Save buttons (fixed labels, no "clean/dirty" UI state) */
        .tool-btn.save {
            height: 44px;
            padding: 10px 14px;
            border-radius: 12px;
            border: 1px solid rgba(16,176,249,0.38);
            background: rgba(16,176,249,0.10);
            color: rgba(245,247,255,0.94);
            font-weight: 800;
        }

        /* Active streams badges */
        .active-streams {
            display: flex;
            gap: var(--space-2);
            flex-wrap: wrap;
        }

        .stream-badge {
            background: rgba(34, 197, 94, 0.15);
            color: var(--color-success);
            padding: var(--space-1) var(--space-3);
            border-radius: var(--radius-lg);
            font-size: var(--text-xs);
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: var(--space-1);
        }

        .stream-badge.current {
            background: rgba(16, 176, 249, 0.15);
            color: var(--color-primary);
        }

        .stream-badge .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: currentColor;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* File upload */
        .file-upload {
            position: relative;
        }

        .file-upload input[type="file"] {
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        /* Hidden class */
        .hidden {
            display: none !important;
        }

        /* Steps indicator */
        .steps {
            display: flex;
            gap: var(--space-2);
        }

        .step {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            padding: 6px 10px;
            background: var(--color-surface-2);
            border-radius: var(--radius-lg);
            font-size: var(--text-sm);
            font-weight: 500;
            color: var(--color-text-subtle);
            border: 1px solid transparent;
            transition: all 0.2s ease;
        }

        .step.active {
            background: rgba(16, 176, 249, 0.15);
            color: var(--color-primary);
            border-color: rgba(16, 176, 249, 0.3);
        }

        .step.done {
            background: rgba(34, 197, 94, 0.1);
            color: var(--color-success);
        }

        .step-num {
            font-family: 'Courier New', monospace;
            font-size: var(--text-xs);
            font-weight: 900;
            line-height: 1;
            padding: 0;
            margin-left: 2px;
            color: rgba(255,255,255,0.92); /* chiffres bien lisibles (dark) */
        }

        :root[data-theme="light"] .step-num { color: rgba(15,23,42,0.92); }

        .step-icon-img {
            width: 14px;
            height: 14px;
            display: inline-block;
            filter: invert(1);
            opacity: 0.9;
        }
        :root[data-theme="light"] .step-icon-img {
            filter: none;
            opacity: 0.85;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--color-surface);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--gray-06);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--gray-05);
        }

        /* Responsive sidebar */
        @media (max-width: 900px) {
            .sidebar {
                transform: translateX(-100%);
                z-index: 100;
            }

            .sidebar.open {
                transform: translateX(0);
            }

            .main-content {
                margin-left: 0;
            }
        }
    </style>
</head>
<body>
    <div class="app-layout">
        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <svg class="logo" viewBox="0 0 1609.48 1543.54" xmlns="http://www.w3.org/2000/svg">
                    <polygon fill="#0b58d8" points="1609.48 1410.4 708.85 1543.42 856.3 1002.13 1148.84 958.84 1148.96 958.87 1609.48 1410.4"/>
                    <polygon fill="#10b0f9" points="856.3 1002.13 708.81 1543.54 708.69 1543.51 0 971.95 625.87 816.5 625.99 816.53 856.18 1002.1 856.3 1002.13"/>
                    <polygon fill="#f93b09" points="1440.85 915.14 998.21 481.22 1129.3 0 1440.85 915.14"/>
                    <polygon fill="#bd44d5" points="1609.48 1410.4 1148.96 958.87 1441.08 915.72 1609.48 1410.4"/>
                    <polygon fill="#fc5607" points="1129.3 0 998.21 481.22 998.12 481.07 396.67 630.56 1129.3 0"/>
                    <polygon fill="#e7ab37" points="625.87 816.5 0 971.95 396.03 631.03 625.87 816.5"/>
                    <polygon fill="#f8d239" points="998.21 481.22 927.27 741.62 625.99 816.53 625.87 816.5 396.03 631.03 396.67 630.56 998.12 481.07 998.21 481.22"/>
                    <polygon fill="#f08321" points="1441.08 915.72 1148.96 958.87 1148.84 958.84 927.27 741.62 998.21 481.22 1440.85 915.14 1441.08 915.72"/>
                    <polygon fill="#062db6" points="1148.84 958.84 856.3 1002.13 927.27 741.62 1148.84 958.84"/>
                    <polygon fill="#7475d8" points="927.27 741.62 856.3 1002.13 856.18 1002.1 625.99 816.53 927.27 741.62"/>
                </svg>
                <span class="logo-text">YRYS</span>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-label">General</div>
                <nav class="sidebar-nav">
                    <a class="nav-item active" id="navSites">
                        <img class="nav-icon-img" src="/static/assets_youn/SvIcons/folder-svgrepo-com.svg" alt="">
                        Sites
                    </a>
                    <a class="nav-item" id="navTracker">
                        <img class="nav-icon-img" src="/static/assets_youn/SvIcons/desktop-svgrepo-com.svg" alt="">
                        Zone Tracker
                    </a>
                </nav>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-label">Active Zones</div>
                <div class="zone-list-sidebar" id="zoneListSidebar">
                    <div style="color: var(--color-text-subtle); font-size: var(--text-sm);">Aucune zone</div>
                </div>
            </div>

            <div class="sidebar-footer">
                <div class="version-badge">©2025 YRYS, Inc — v1.0</div>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Header -->
            <header class="header-bar">
                <div>
                    <h1 class="page-title" id="pageTitle">Zone Presence Tracker</h1>
                    <p class="page-subtitle" id="pageSubtitle">Surveillance et analyse du temps de présence</p>
                </div>
                <div class="header-actions">
                    <div class="steps">
                        <div class="step" id="step1" title="Caméra">
                            <img class="step-icon-img" src="/static/assets_youn/SvIcons/video-camera-svgrepo-com.svg" alt="">
                            <span class="step-num">1</span>
                        </div>
                        <div class="step" id="step2" title="Zones">
                            <img class="step-icon-img" src="/static/assets_youn/SvIcons/includezone.svg" alt="">
                            <span class="step-num">2</span>
                        </div>
                        <div class="step" id="step3" title="Détection">
                            <img class="step-icon-img" src="/static/assets_youn/SvIcons/checkmark-svgrepo-com.svg" alt="">
                            <span class="step-num">3</span>
                        </div>
                    </div>
                    <div class="status-indicator ready" id="statusBadge">
                        <span class="status-dot-indicator"></span>
                        <span id="statusText">Prêt</span>
                    </div>
                </div>
            </header>

            <!-- Home (Sites) -->
            <section class="zones-section" id="homeView">
                <div class="card">
                    <div class="card-header">
                        <div>
                            <div class="card-subtitle">Multi-site</div>
                            <div class="card-title">Sites</div>
                        </div>
                    </div>
                    <div style="padding: var(--space-4); border-top: 1px solid var(--color-border); display:flex; gap: var(--space-3); align-items:center; flex-wrap:wrap;">
                        <input id="newSiteName" type="text" placeholder="Nom du site (ex: Entrepôt Lyon)" style="flex:1; min-width: 260px; padding: 12px 14px; border-radius: var(--radius-md); border: 1px solid var(--color-border); background: var(--color-surface-2); color: var(--color-text); outline: none;">
                        <button class="btn btn-primary" id="createSiteBtn" type="button">Créer le site</button>
                    </div>
                    <div style="padding: var(--space-4);">
                        <div class="zones-grid" id="sitesGrid" style="grid-template-columns: repeat(3, minmax(0, 1fr));">
                            <div class="no-zones">Aucun site. Créez-en un pour commencer.</div>
                        </div>
                    </div>
                </div>
            </section>

            <div id="trackerView" class="hidden">
            <!-- Video Section -->
            <section class="video-section">
                <div class="video-card">
                    <div class="video-card-header">
                        <div class="video-title">
                            <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
                            </svg>
                            <span id="currentVideoTitle">Sélectionner une vidéo</span>
                        </div>
                        <div class="active-streams" id="activeStreams"></div>
                    </div>

                    <div class="video-wrapper" id="videoWrapper">
                        <div class="draw-hud hidden" id="drawHud">
                            <div class="draw-hud-left">
                                <div class="draw-hud-title" id="drawHudTitle">Mode dessin</div>
                                <div class="draw-instructions visible" id="drawInstructions">
                                    <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                    </svg>
                                    Cliquez pour placer les points
                                </div>
                            </div>
                            <div class="draw-hud-actions">
                                <button class="btn btn-secondary btn-small" id="undoBtn">Annuler pt</button>
                                <button class="btn btn-primary btn-small" id="finishBtn" disabled>Enregistrer dessin</button>
                                <button class="btn btn-danger btn-small" id="cancelBtn">Annuler</button>
                            </div>
                        </div>
                        <div class="video-placeholder" id="placeholder">
                            <div class="video-placeholder-icon">
                                <img src="/static/assets_youn/SvIcons/video-camera-svgrepo-com.svg" alt="" style="width:44px;height:44px;opacity:0.55;">
                            </div>
                            <div>Sélectionnez une vidéo pour commencer</div>
                        </div>
                        <div class="video-container" id="videoContainer">
                            <img id="videoFrame" class="hidden" alt="Video frame">
                            <img id="videoStream" class="hidden" alt="Video stream">
                            <canvas id="drawCanvas" class="hidden"></canvas>
                        </div>

                        <!-- Dessin: bouton overlay (bas-droite) -->
                        <button class="video-fab" id="drawFab" title="Dessin" type="button">
                            <img src="/static/assets_youn/SvIcons/draw.svg" alt="">
                        </button>
                    </div>

                    <div class="video-toolbar">
                        <!-- Source vidéo: gérée via la liste des caméras (masqué pour garder le mécanisme interne) -->
                        <div class="hidden">
                            <select id="videoSelect">
                                <option value="">-- Choisir une vidéo --</option>
                            </select>
                            <input type="file" id="videoUpload" accept="video/*">
                        </div>

                        <div class="form-row">
                            <button class="btn btn-secondary hidden" id="toggleDrawPanelBtn">
                                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"/>
                                </svg>
                                Dessin
                            </button>
                            <div class="draw-panel hidden" id="drawPanel">
                                <div class="form-group">
                                    <label class="form-label">Zone</label>
                                    <select id="drawZoneSelect">
                                        <option value="">— Choisir —</option>
                                        <option value="__new__">+ Nouvelle zone…</option>
                                    </select>
                                </div>
                                <div class="form-group hidden" id="drawZoneNameGroup">
                                    <label class="form-label">Nom de zone</label>
                                    <input type="text" id="drawZoneName" placeholder="Ex: Zone A">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Outil</label>
                                    <div class="segmented">
                                        <button class="btn btn-secondary btn-small active" id="toolPolyBtn" type="button">Polygone</button>
                                        <button class="btn btn-secondary btn-small" id="toolLineBtn" type="button">Ligne</button>
                                    </div>
                                </div>
                                <button class="btn btn-primary" id="startDrawBtn" type="button">Tracer</button>
                                <button class="btn btn-secondary" id="stopDrawBtn" type="button">Terminer</button>
                                <div style="width: 1px; height: 28px; background: var(--color-border);"></div>
                                <button class="btn btn-secondary btn-small" id="editSelectedBtn" type="button">Éditer</button>
                                <button class="btn btn-secondary btn-small" id="addPointBtn" type="button">+ Point</button>
                                <button class="btn btn-secondary btn-small" id="deletePointBtn" type="button">- Point</button>
                                <button class="btn btn-primary btn-small" id="saveEditBtn" type="button">Sauver</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Camera/Control Panel -->
                <div class="camera-panel">
                    <div class="card">
                        <div class="card-header">
                            <div>
                                <div class="card-subtitle">Contrôles</div>
                                <div class="card-title">Actions</div>
                            </div>
                        </div>
                        <div style="display: flex; flex-direction: column; gap: var(--space-3);">
                            <button class="btn btn-primary" id="startDetectionBtn" disabled style="width: 100%;">
                                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"/>
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                </svg>
                                Lancer la détection
                            </button>
                            <button class="btn btn-danger hidden" id="stopDetectionBtn" style="width: 100%;">
                                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 10a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 01-1-1v-4z"/>
                                </svg>
                                Pause
                            </button>
                            <button class="btn btn-danger hidden" id="stopAllBtn" style="width: 100%;">Arrêter tout</button>
                            <button class="btn btn-secondary" id="toggleBlurBtn" style="width: 100%;">
                                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21"/>
                                </svg>
                                Floutage: OFF
                            </button>
                        </div>
                    </div>

                    <div class="card">
                        <div class="card-header">
                            <div>
                                <div class="card-subtitle">Vidéos disponibles</div>
                                <div class="card-title">Caméras</div>
                            </div>
                            <button class="btn btn-secondary btn-icon" id="addCameraBtn" title="Ajouter une caméra" type="button">+</button>
                        </div>
                        <div class="hidden" id="addCameraForm" style="padding: var(--space-4); border-top: 1px solid var(--color-border); display:flex; flex-direction:column; gap: var(--space-3);">
                            <div style="display:flex; gap: var(--space-3); flex-wrap:wrap;">
                                <div class="form-group" style="flex:1; min-width:200px;">
                                    <label class="form-label">Nom caméra</label>
                                    <input id="newCamName" type="text" placeholder="Ex: Entrepôt" style="width:100%;">
                                </div>
                                <div class="form-group" style="flex:1; min-width:200px;">
                                    <label class="form-label">Vidéo</label>
                                    <select id="newCamVideo" class="lov-select" style="width:100%;"></select>
                                </div>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Description (optionnel)</label>
                                <input id="newCamHint" type="text" placeholder="Ex: Déchargement & présence" style="width:100%;">
                            </div>
                            <div style="display:flex; gap: var(--space-3);">
                                <button class="btn btn-primary" id="saveCamBtn" type="button">Ajouter</button>
                                <button class="btn btn-secondary" id="cancelCamBtn" type="button">Annuler</button>
                            </div>
                        </div>
                        <div class="camera-grid" id="cameraGrid">
                            <!-- Cameras will be populated here -->
                        </div>
                    </div>
                </div>
            </section>

            <!-- Zones Section -->
            <section class="zones-section">
                <div class="card">
                    <div class="card-header">
                        <div>
                            <div class="card-subtitle">Présences</div>
                            <div class="card-title">Temps de présence par zone</div>
                        </div>
                        <button class="btn btn-danger" id="deleteAllZonesBtn">
                            <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
                            </svg>
                            Reset timers
                        </button>
                    </div>
                    <div class="zones-grid" id="zonesGrid">
                        <div class="no-zones">Aucune zone définie pour cette vidéo</div>
                    </div>
                    <div class="recap-grid" id="recapGrid" style="display:grid; grid-template-columns: repeat(4, minmax(0,1fr)); gap: var(--space-4); padding: var(--space-4); border-top: 1px solid var(--color-border);">
                        <div class="card" style="background: transparent; border: 0; box-shadow: none; padding: 0;">
                            <div class="card-subtitle">Caméras</div>
                            <div class="card-title" id="recapCameras">—</div>
                            <div style="color: var(--color-text-muted); font-size: var(--text-xs);" id="recapCamerasSub">—</div>
                        </div>
                        <div class="card" style="background: transparent; border: 0; box-shadow: none; padding: 0;">
                            <div class="card-subtitle">Zones</div>
                            <div class="card-title" id="recapZones">—</div>
                            <div style="color: var(--color-text-muted); font-size: var(--text-xs);" id="recapZonesSub">—</div>
                        </div>
                        <div class="card" style="background: transparent; border: 0; box-shadow: none; padding: 0;">
                            <div class="card-subtitle">Dessins</div>
                            <div class="card-title" id="recapDrawings">—</div>
                            <div style="color: var(--color-text-muted); font-size: var(--text-xs);" id="recapDrawingsSub">—</div>
                        </div>
                        <div class="card" style="background: transparent; border: 0; box-shadow: none; padding: 0;">
                            <div class="card-subtitle">Présences actives</div>
                            <div class="card-title" id="recapActive">—</div>
                            <div style="color: var(--color-text-muted); font-size: var(--text-xs);" id="recapActiveSub">—</div>
                        </div>
                    </div>
                </div>
            </section>
            </div>
        </main>
    </div>

    <!-- Drawing Editor Modal (paint-like) -->
    <div class="editor-overlay hidden" id="editorOverlay" role="dialog" aria-modal="true" aria-label="Éditeur de zones">
        <div class="editor">
            <div class="editor-topbar">
                <div>
                    <div class="editor-title" id="editorTitle">Video Editing</div>
                    <div class="editor-subtitle" id="editorSubtitle">Outils de dessin</div>
                </div>
                <button class="btn btn-ghost btn-icon" id="editorCloseBtn" title="Fermer">
                    <svg width="18" height="18" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                    </svg>
                </button>
            </div>

            <div class="editor-body">
                <div class="editor-left">
                    <div class="editor-canvas-wrap">
                        <img id="editorFrame" alt="Frame">
                        <canvas id="editorCanvas"></canvas>
                        <div class="editor-hoverbar hidden" id="editorHoverBar">
                            <button class="editor-hoverbtn danger" id="hoverDeletePointBtn" title="Supprimer le point">
                                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 6l12 12M18 6L6 18"/>
                                </svg>
                            </button>
                            <button class="editor-hoverbtn danger" id="hoverDeleteShapeBtn" title="Supprimer la forme">
                                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                                </svg>
                            </button>
                        </div>
                    </div>

                    <div class="editor-tools">
                        <div class="tool-row">
                            <button class="tool-btn icon primary active" id="toolSelectBtn" title="Sélection">
                                <img class="tool-ico" src="/static/assets_youn/SvIcons/circle-svgrepo-com.svg" alt="">
                                <span class="tool-label">Sélect</span>
                            </button>
                            <button class="tool-btn icon" id="toolCountLineBtn" title="Ligne de comptage">
                                <img class="tool-ico" src="/static/assets_youn/SvIcons/user-svgrepo-com.svg" alt="">
                                <span class="tool-label">Compter</span>
                            </button>
                            <button class="tool-btn icon green" id="toolIncludeBtn" title="Zone d’inclusion">
                                <img class="tool-ico" src="/static/assets_youn/SvIcons/includezone.svg" alt="">
                                <span class="tool-label">Inclure</span>
                            </button>
                            <button class="tool-btn icon yellow" id="toolExcludeBtn" title="Zone d’exclusion">
                                <img class="tool-ico" src="/static/assets_youn/SvIcons/intersect-svgrepo-com%20(1).svg" alt="">
                                <span class="tool-label">Exclure</span>
                            </button>
                            <button class="tool-btn icon" id="toolUndoBtn" title="Annuler (Ctrl+Z)">
                                ↶
                                <span class="tool-label">Annuler</span>
                            </button>
                            <button class="tool-btn icon red" id="toolClearBtn" title="Tout effacer">✕</button>
                            <button class="tool-btn save" id="toolSaveBtn" title="Sauvegarder toute la configuration">Sauvegarder</button>
                        </div>

                        <div class="editor-guide" id="editorGuide">
                            1) Choisissez une zone à droite. 2) Dessinez (ligne ou polygone). 3) Ajustez les points. 4) Sauvegardez.
                        </div>
                    </div>
                </div>

                <div class="editor-right">
                    <div class="editor-card">
                        <h3>Informations sur la caméra</h3>
                        <div class="editor-kv">
                            <div class="k">ID</div><div id="editorCamId">—</div>
                            <div class="k">Rés.</div><div id="editorCamRes">—</div>
                            <div class="k">Statut</div><div id="editorCamStatus">—</div>
                            <div class="k">Src.</div><div id="editorCamSource">—</div>
                        </div>
                    </div>

                    <div class="editor-card">
                        <h3>Associated Zones</h3>
                        <div class="editor-zones" id="editorZoneList"></div>
                        <div style="margin-top: 10px; display:flex; gap:8px;">
                            <input type="text" id="editorNewZoneName" placeholder="Nouvelle zone…" style="flex:1; min-width:0; background: rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.12); color:#F5F7FF;">
                            <button class="tool-btn primary" id="editorAddZoneBtn">+</button>
                        </div>
                        <div style="margin-top: 10px; display:flex; justify-content:flex-end;">
                            <button class="tool-btn red" id="editorDeleteZoneBtn" title="Supprimer la zone sélectionnée">Supprimer la zone</button>
                        </div>
                    </div>

                    <div class="editor-card">
                        <h3>Contrôles</h3>
                        <div class="editor-kv">
                            <div class="k">Lecture</div><div>Frame fixe (édition)</div>
                            <div class="k">Astuce</div><div>Glissez un point pour le déplacer. Maintenez <b>Shift</b> et cliquez près d’une arête pour ajouter un point.</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="editor-bottombar">
                <button class="btn btn-primary editor-save-main" id="editorSaveBtn" title="Sauvegarder toute la configuration">Sauvegarder tout</button>
                <button class="btn btn-secondary" id="editorCloseBtn2" title="Fermer l’éditeur">Fermer</button>
            </div>
        </div>
    </div>

    <!-- App Modal (internal alerts/confirm) -->
    <div class="editor-overlay hidden" id="appModalOverlay" role="dialog" aria-modal="true" aria-label="Message">
        <div class="editor" style="width:min(520px, 100%); height:auto;">
            <div class="editor-topbar">
                <div>
                    <div class="editor-title" id="appModalTitle">Message</div>
                    <div class="editor-subtitle" id="appModalSubtitle">Zone Tracker</div>
                </div>
                <button class="btn btn-ghost btn-icon" id="appModalCloseBtn" title="Fermer">✕</button>
            </div>
            <div style="padding: 16px; background: #1B1E27; color:#F5F7FF; border-top:1px solid rgba(255,255,255,0.08);">
                <div id="appModalMessage" style="white-space: pre-wrap; color: rgba(245,247,255,0.85); line-height:1.5;"></div>
            </div>
            <div class="editor-bottombar">
                <button class="tool-btn" id="appModalCancelBtn">Annuler</button>
                <button class="tool-btn primary" id="appModalOkBtn">OK</button>
            </div>
        </div>
    </div>

    <script>
        // State
        let currentVideo = null;
        let currentCameraId = null;
        let currentView = 'home'; // 'home' | 'tracker'
        // DEMO mode: sites live only in memory (refresh => reset)
        const DEMO_SITES = [
            {
                name: 'Site Démo',
                cameras: [
                    { id: 'cam1', name: 'Entrepôt', hint: 'Déchargement & présence', video: 'entr1.mp4' },
                    { id: 'cam2', name: 'Convoyeur', hint: 'Tapis roulant & contrôle', video: 'video_01.mp4' }
                ]
            }
        ];
        let sitesCache = structuredClone ? structuredClone(DEMO_SITES) : JSON.parse(JSON.stringify(DEMO_SITES));
        let currentSite = null; // { name, cameras, created_at }
        let availableVideosList = [];
        // Détection: on calcule les % / absences uniquement pendant la détection (pas “depuis que je regarde la page”)
        const videoRunAccumSecByVideo = {}; // { [videoName]: seconds } cumulé (hors session courante)
        const videoRunStartTsByVideo = {};  // { [videoName]: epochMs } start de la session courante si en cours
        const videoHasRunByVideo = {};      // { [videoName]: boolean } true dès qu'on a lancé au moins une fois pendant cette session
        const lastPresenceByVideo = {};     // { [videoName]: presenceZones } snapshot gelé quand en pause
        const zoneLiveTimersByVideo = {};  // { [videoName]: { lastTs:number, zones:{[zone]:{occ:number, abs:number}} } }
        const zonesCacheByVideo = {};      // { [videoName]: zonesWithPolygons } (définitions)
        let zonesCacheRefreshTs = 0;
        const linePassByVideo = {};        // { [videoName]: { [zoneName]: { count:number, lastOcc:boolean, series:number[] } } }
        const zonesDefsFetchTsByVideo = {}; // { [videoName]: epochMs } pour throttle /api/zones/{video}
        const zonesDefsFetchedByVideo = {}; // { [videoName]: boolean } pour distinguer "0 zones" vs "pas encore fetch"
        const presenceOkTsByVideo = {};     // { [videoName]: epochMs } dernier /api/presence OK (anti-stale)
        let loadZonesInFlight = false;
        let loadZonesLoopTimer = null;
        const PRESENCE_POLL_ACTIVE_MS = 350;
        const PRESENCE_POLL_IDLE_MS = 1000;
        const ZONES_DEF_TTL_MS = 2500;
        const PRESENCE_STALE_MS = 1400; // si on n'a pas eu de /presence OK depuis trop longtemps, ne pas afficher "Occupé"

        function markVideoRunStart(video) {
            if (!video) return;
            if (videoRunAccumSecByVideo[video] == null) videoRunAccumSecByVideo[video] = 0;
            if (!videoRunStartTsByVideo[video]) videoRunStartTsByVideo[video] = Date.now();
            videoHasRunByVideo[video] = true;
        }

        function markVideoRunStop(video) {
            if (!video) return;
            const start = videoRunStartTsByVideo[video];
            if (!start) return;
            const dt = Math.max(0, (Date.now() - start) / 1000);
            videoRunAccumSecByVideo[video] = Number(videoRunAccumSecByVideo[video] || 0) + dt;
            delete videoRunStartTsByVideo[video];
        }

        function markAllRunsStop() {
            try {
                for (const v of Array.from(activeVideoStreams || [])) markVideoRunStop(v);
            } catch {}
        }

        function getVideoRunTotalSec(video) {
            const acc = Number(videoRunAccumSecByVideo[video] || 0);
            const start = videoRunStartTsByVideo[video];
            if (activeVideoStreams.has(video) && start) {
                return acc + Math.max(0, (Date.now() - start) / 1000);
            }
            return acc;
        }

        function formatHMS(totalSeconds) {
            const s = Math.max(0, Math.floor(Number(totalSeconds) || 0));
            const h = Math.floor(s / 3600);
            const m = Math.floor((s % 3600) / 60);
            const ss = s % 60;
            const pad = (n) => String(n).padStart(2, '0');
            return `${pad(h)}:${pad(m)}:${pad(ss)}`;
        }

        function ensureZoneLive(video) {
            if (!zoneLiveTimersByVideo[video]) zoneLiveTimersByVideo[video] = { lastTs: 0, zones: {} };
            if (!zoneLiveTimersByVideo[video].zones) zoneLiveTimersByVideo[video].zones = {};
            return zoneLiveTimersByVideo[video];
        }

        function updateZoneLiveTimers(video, presenceZones) {
            if (!video) return;
            if (!activeVideoStreams.has(video)) return; // ne compte que pendant la détection
            const v = ensureZoneLive(video);
            const now = Date.now();
            const last = Number(v.lastTs || 0);
            const dt = last ? Math.max(0, (now - last) / 1000) : 0;
            v.lastTs = now;
            if (!dt) return;

            // union des zones connues + zones présentes
            const names = new Set([
                ...Object.keys(v.zones || {}),
                ...Object.keys(presenceZones || {})
            ]);
            for (const name of names) {
                if (!v.zones[name]) v.zones[name] = { occ: 0, abs: 0 };
                const isOcc = !!(presenceZones?.[name]?.is_occupied);
                if (isOcc) v.zones[name].occ += dt;
                else v.zones[name].abs += dt;
            }
        }

        function resetLocalTimersAll() {
            try {
                for (const k of Object.keys(zoneLiveTimersByVideo)) delete zoneLiveTimersByVideo[k];
                for (const k of Object.keys(videoRunAccumSecByVideo)) delete videoRunAccumSecByVideo[k];
                for (const k of Object.keys(videoRunStartTsByVideo)) delete videoRunStartTsByVideo[k];
                for (const k of Object.keys(videoHasRunByVideo)) delete videoHasRunByVideo[k];
                for (const k of Object.keys(lastPresenceByVideo)) delete lastPresenceByVideo[k];
                for (const k of Object.keys(zonesCacheByVideo)) delete zonesCacheByVideo[k];
            } catch {}
        }

        function resetLocalTimersZone(video, zoneName) {
            if (!video || !zoneName) return;
            const v = zoneLiveTimersByVideo[video];
            if (v?.zones?.[zoneName]) v.zones[zoneName] = { occ: 0, abs: 0 };
            // ne touche pas lastTs: le tick continue si détection tourne
            try {
                const lp = linePassByVideo?.[video]?.[zoneName];
                if (lp) { lp.count = 0; lp.series = []; lp.lastOcc = false; }
            } catch {}
        }

        function ensureLinePass(video) {
            if (!linePassByVideo[video]) linePassByVideo[video] = {};
            return linePassByVideo[video];
        }

        function updateLinePass(video, presenceZones, isLineZoneFn) {
            if (!video || !presenceZones) return;
            const store = ensureLinePass(video);
            for (const [zoneName, info] of Object.entries(presenceZones || {})) {
                if (!isLineZoneFn(zoneName)) continue;
                if (!store[zoneName]) store[zoneName] = { count: 0, lastOcc: false, series: [] };
                const cur = !!info?.is_occupied;
                if (cur && !store[zoneName].lastOcc) store[zoneName].count += 1;
                store[zoneName].lastOcc = cur;
                store[zoneName].series.push(cur ? 1 : 0);
                if (store[zoneName].series.length > 80) store[zoneName].series.splice(0, store[zoneName].series.length - 80);
            }
        }

        function buildSparklineSvg(series) {
            const s = Array.isArray(series) ? series : [];
            const n = s.length;
            const w = 120, h = 26;
            if (n < 2) {
                return `<svg viewBox="0 0 ${w} ${h}" preserveAspectRatio="none"><line class="base" x1="0" y1="${h-4}" x2="${w}" y2="${h-4}" /></svg>`;
            }
            const padY = 4;
            const xStep = w / (n - 1);
            const pts = s.map((v, i) => {
                const x = i * xStep;
                const y = (h - padY) - (v ? 14 : 0);
                return `${x.toFixed(1)},${y.toFixed(1)}`;
            }).join(' ');
            return `
                <svg viewBox="0 0 ${w} ${h}" preserveAspectRatio="none">
                    <line class="base" x1="0" y1="${h-4}" x2="${w}" y2="${h-4}" />
                    <polyline class="wave" points="${pts}" />
                </svg>
            `;
        }

        async function refreshZonesCacheForSite(force = false) {
            if (!currentSite?.cameras?.length) return;
            const now = Date.now();
            if (!force && (now - zonesCacheRefreshTs) < 2000) return; // throttle
            zonesCacheRefreshTs = now;
            const videos = currentSite.cameras.map(c => c.video).filter(Boolean);
            await Promise.all(videos.map(async (v) => {
                try {
                    const res = await fetch(`/api/zones/${encodeURIComponent(v)}`);
                    const data = await res.json();
                    zonesCacheByVideo[v] = data.zones || {};
                } catch {}
            }));
        }

        function computeSiteStats() {
            const cams = (currentSite?.cameras || []);
            const camCount = cams.length;

            // total zones sur toutes les caméras (définitions)
            let zoneCount = 0;
            const videos = cams.map(c => c.video).filter(Boolean);
            for (const v of videos) {
                zoneCount += Object.keys(zonesCacheByVideo[v] || {}).length;
            }

            // taux d’occupation moyen pondéré par le temps de détection:
            // moyenne = (Σ occSec) / (Σ (occSec+absSec)) sur toutes les zones/toutes les caméras
            let totalOcc = 0;
            let totalDen = 0;
            for (const v of videos) {
                const z = zoneLiveTimersByVideo?.[v]?.zones || {};
                // Important: ne calculer QUE sur les zones existantes (définitions),
                // sinon une zone supprimée peut continuer à polluer la moyenne via les timers locaux.
                const names = Object.keys(zonesCacheByVideo[v] || {});
                for (const name of names) {
                    const occ = Number(z?.[name]?.occ || 0);
                    const abs = Number(z?.[name]?.abs || 0);
                    const den = occ + abs;
                    totalOcc += occ;
                    totalDen += den;
                }
            }
            const avgOcc = totalDen > 0 ? (totalOcc / totalDen) : 0;
            return { camCount, zoneCount, avgOcc };
        }

        function updateHeaderStepsKpis() {
            if (!step1Num || !step2Num || !step3Num) return;
            if (currentView !== 'tracker' || !currentSite) {
                step1Num.textContent = '—';
                step2Num.textContent = '—';
                step3Num.textContent = '—';
                return;
            }
            const { camCount, zoneCount, avgOcc } = computeSiteStats();
            step1Num.textContent = String(camCount);
            step2Num.textContent = String(zoneCount);
            step3Num.textContent = `${Math.round(avgOcc * 100)}%`;
        }
        let isDrawing = false;
        let isCurrentVideoStreaming = false;
        let drawPoints = [];
        let videoWidth = 0;
        let videoHeight = 0;
        let activeVideoStreams = new Set();
        let drawMode = 'poly'; // 'poly' | 'line'
        let activeDrawZoneName = '';
        let zonePolygonCounts = {}; // { [zoneName]: number }
        let selectedAsset = null; // { zone: string, idx?: number }
        let editMode = false;
        let editPoints = null; // points being edited (array of [x,y])
        let editDragging = null; // { idx: number }
        const HANDLE_RADIUS = 10;

        // Elements
        const videoSelect = document.getElementById('videoSelect');
        const videoUpload = document.getElementById('videoUpload');
        const videoFrame = document.getElementById('videoFrame');
        const videoStream = document.getElementById('videoStream');
        const videoContainer = document.getElementById('videoContainer');
        const drawCanvas = document.getElementById('drawCanvas');
        const ctx = drawCanvas.getContext('2d');
        const placeholder = document.getElementById('placeholder');
        const toggleDrawPanelBtn = document.getElementById('toggleDrawPanelBtn');
        const drawFab = document.getElementById('drawFab');
        const drawPanel = document.getElementById('drawPanel');
        const drawZoneSelect = document.getElementById('drawZoneSelect');
        const drawZoneNameGroup = document.getElementById('drawZoneNameGroup');
        const drawZoneName = document.getElementById('drawZoneName');
        const toolPolyBtn = document.getElementById('toolPolyBtn');
        const toolLineBtn = document.getElementById('toolLineBtn');
        const startDrawBtn = document.getElementById('startDrawBtn');
        const stopDrawBtn = document.getElementById('stopDrawBtn');
        const editSelectedBtn = document.getElementById('editSelectedBtn');
        const addPointBtn = document.getElementById('addPointBtn');
        const deletePointBtn = document.getElementById('deletePointBtn');
        const saveEditBtn = document.getElementById('saveEditBtn');
        const drawHud = document.getElementById('drawHud');
        const drawHudTitle = document.getElementById('drawHudTitle');
        const undoBtn = document.getElementById('undoBtn');
        const finishBtn = document.getElementById('finishBtn');
        const cancelBtn = document.getElementById('cancelBtn');
        const drawInstructions = document.getElementById('drawInstructions');
        const startDetectionBtn = document.getElementById('startDetectionBtn');
        const stopDetectionBtn = document.getElementById('stopDetectionBtn');
        const stopAllBtn = document.getElementById('stopAllBtn');
        const zonesGrid = document.getElementById('zonesGrid');
        const statusBadge = document.getElementById('statusBadge');
        const statusText = document.getElementById('statusText');
        const step1Num = document.querySelector('#step1 .step-num');
        const step2Num = document.querySelector('#step2 .step-num');
        const step3Num = document.querySelector('#step3 .step-num');
        const activeStreamsDiv = document.getElementById('activeStreams');
        const cameraGrid = document.getElementById('cameraGrid');
        const currentVideoTitle = document.getElementById('currentVideoTitle');
        const zoneListSidebar = document.getElementById('zoneListSidebar');
        const recapCameras = document.getElementById('recapCameras');
        const recapCamerasSub = document.getElementById('recapCamerasSub');
        const recapZones = document.getElementById('recapZones');
        const recapZonesSub = document.getElementById('recapZonesSub');
        const recapDrawings = document.getElementById('recapDrawings');
        const recapDrawingsSub = document.getElementById('recapDrawingsSub');
        const recapActive = document.getElementById('recapActive');
        const recapActiveSub = document.getElementById('recapActiveSub');

        // Multi-site UI
        const homeView = document.getElementById('homeView');
        const trackerView = document.getElementById('trackerView');
        const sitesGrid = document.getElementById('sitesGrid');
        const newSiteNameInput = document.getElementById('newSiteName');
        const createSiteBtn = document.getElementById('createSiteBtn');
        const navSites = document.getElementById('navSites');
        const navTracker = document.getElementById('navTracker');
        const pageTitleEl = document.getElementById('pageTitle');
        const pageSubtitleEl = document.getElementById('pageSubtitle');
        const stepsEl = document.querySelector('.steps');

        // Cameras (per site)
        const addCameraBtn = document.getElementById('addCameraBtn');
        const addCameraForm = document.getElementById('addCameraForm');
        const newCamName = document.getElementById('newCamName');
        const newCamVideo = document.getElementById('newCamVideo');
        const newCamHint = document.getElementById('newCamHint');
        const saveCamBtn = document.getElementById('saveCamBtn');
        const cancelCamBtn = document.getElementById('cancelCamBtn');

        // Editor modal elements
        const editorOverlay = document.getElementById('editorOverlay');
        const editorCloseBtn = document.getElementById('editorCloseBtn');
        const editorCloseBtn2 = document.getElementById('editorCloseBtn2');
        const editorSaveBtn = document.getElementById('editorSaveBtn');
        const editorTitle = document.getElementById('editorTitle');
        const editorSubtitle = document.getElementById('editorSubtitle');
        const editorFrame = document.getElementById('editorFrame');
        const editorCanvas = document.getElementById('editorCanvas');
        const editorCtx = editorCanvas.getContext('2d');
        const editorCamId = document.getElementById('editorCamId');
        const editorCamSource = document.getElementById('editorCamSource');
        const editorCamRes = document.getElementById('editorCamRes');
        const editorCamStatus = document.getElementById('editorCamStatus');
        const editorZoneList = document.getElementById('editorZoneList');
        const editorNewZoneName = document.getElementById('editorNewZoneName');
        const editorAddZoneBtn = document.getElementById('editorAddZoneBtn');
        const editorDeleteZoneBtn = document.getElementById('editorDeleteZoneBtn');
        const toolSelectBtn = document.getElementById('toolSelectBtn');
        const toolCountLineBtn = document.getElementById('toolCountLineBtn');
        const toolIncludeBtn = document.getElementById('toolIncludeBtn');
        const toolExcludeBtn = document.getElementById('toolExcludeBtn');
        const toolUndoBtn = document.getElementById('toolUndoBtn');
        const toolClearBtn = document.getElementById('toolClearBtn');
        const toolSaveBtn = document.getElementById('toolSaveBtn');
        const editorGuide = document.getElementById('editorGuide');
        const editorHoverBar = document.getElementById('editorHoverBar');
        const hoverDeletePointBtn = document.getElementById('hoverDeletePointBtn');
        const hoverDeleteShapeBtn = document.getElementById('hoverDeleteShapeBtn');

        // App modal (internal alert/confirm)
        const appModalOverlay = document.getElementById('appModalOverlay');
        const appModalTitle = document.getElementById('appModalTitle');
        const appModalSubtitle = document.getElementById('appModalSubtitle');
        const appModalMessage = document.getElementById('appModalMessage');
        const appModalOkBtn = document.getElementById('appModalOkBtn');
        const appModalCancelBtn = document.getElementById('appModalCancelBtn');
        const appModalCloseBtn = document.getElementById('appModalCloseBtn');

        let __modalResolve = null;

        function uiModal({ title = 'Message', subtitle = 'Zone Tracker', message = '', okText = 'OK', cancelText = null } = {}) {
            if (!appModalOverlay) return Promise.resolve(true);
            appModalTitle.textContent = title;
            appModalSubtitle.textContent = subtitle;
            appModalMessage.textContent = message;
            appModalOkBtn.textContent = okText;
            appModalCancelBtn.textContent = cancelText || '';
            appModalCancelBtn.classList.toggle('hidden', !cancelText);
            appModalOverlay.classList.remove('hidden');

            return new Promise((resolve) => {
                __modalResolve = resolve;
            });
        }

        function uiAlert(message, title = 'Info') {
            return uiModal({ title, message, okText: 'OK', cancelText: null });
        }

        function uiConfirm(message, title = 'Confirmer') {
            return uiModal({ title, message, okText: 'Confirmer', cancelText: 'Annuler' });
        }

        const editorState = {
            open: false,
            tool: 'select', // select | line | poly
            zone: null,
            polygonIdx: null,
            mode: 'idle', // idle | creating | editing
            points: [],
            lineDirEnd: null, // [x,y] canvas coords: extrémité de la flèche (brouillon ligne)
            drag: null, // { kind: 'vertex'|'poly', vIdx?:number, start?:[x,y] }
            undo: [],
            zones: {}, // from /api/zones/{video}
            presence: {}, // from /api/presence/{video}
            w: 0,
            h: 0,
            dirty: false,
            autosaveTimer: null,
            didDrag: false,
            lastSavedTs: 0
        };

        function setTool(tool) {
            drawMode = tool;
            toolPolyBtn.classList.toggle('active', tool === 'poly');
            toolLineBtn.classList.toggle('active', tool === 'line');
            updateFinishButtonState();
        }

        // ===== Editor modal logic (paint-like) =====
        function editorSetTool(tool) {
            editorState.tool = tool;
            toolSelectBtn.classList.toggle('active', tool === 'select');
            toolCountLineBtn.classList.toggle('active', tool === 'line');
            toolIncludeBtn.classList.toggle('active', tool === 'include');
            toolExcludeBtn.classList.toggle('active', tool === 'exclude');
            editorState.lineDirEnd = null;
            editorGuide.textContent =
                tool === 'select'
                    ? 'Sélection: cliquez un point (hit zone large) puis glissez pour déplacer. Shift + clic près d’une arête = ajouter un point.'
                    : tool === 'line'
                        ? 'Ligne de comptage: 2 clics pour placer départ/arrivée. Ensuite tirez la flèche depuis le centre pour le sens. Puis Sauver.'
                        : tool === 'exclude'
                            ? 'Zone d’exclusion: cliquez pour placer des points (3+), puis Sauver.'
                            : 'Zone d’inclusion: cliquez pour placer des points (3+), puis Sauver.';
        }

        function editorPushUndo() {
            const snapshot = {
                tool: editorState.tool,
                zone: editorState.zone,
                polygonIdx: editorState.polygonIdx,
                mode: editorState.mode,
                points: clonePoints(editorState.points),
            };
            editorState.undo.push(snapshot);
            if (editorState.undo.length > 50) editorState.undo.shift();
        }

        function editorPopUndo() {
            const s = editorState.undo.pop();
            if (!s) return;
            editorState.tool = s.tool;
            editorState.zone = s.zone;
            editorState.polygonIdx = s.polygonIdx;
            editorState.mode = s.mode;
            editorState.points = clonePoints(s.points);
            editorSetTool(editorState.tool);
            editorRender();
        }

        function editorClearTemp() {
            editorState.mode = 'idle';
            editorState.points = [];
            editorState.drag = null;
            editorState.polygonIdx = null;
            editorState.lineDirEnd = null;
            editorRender();
        }

        function editorScheduleAutosave() {
            if (!currentVideo || !editorState.zone) return;
            editorState.dirty = true;
            if (editorState.autosaveTimer) clearTimeout(editorState.autosaveTimer);
            editorState.autosaveTimer = setTimeout(async () => {
                try {
                    await editorPutNow();
                } catch (e) {
                    console.warn('Autosave failed', e);
                }
            }, 650);
        }

        async function editorPutNow() {
            if (!currentVideo || !editorState.zone) return;
            const zoneName = editorState.zone;
            const polygons = editorState.zones?.[zoneName]?.polygons || [];
            const putRes = await fetch(`/api/zones/${encodeURIComponent(currentVideo)}/${encodeURIComponent(zoneName)}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ polygons })
            });
            if (!putRes.ok) throw new Error('PUT zone failed');
            editorState.dirty = false;
            editorState.lastSavedTs = Date.now();
            // sync main view quietly (force pour refléter immédiatement les changements)
            try { await refreshMainAfterEditor(true); } catch {}
        }

        async function editorPostNewPolygon(type, poly, extraMeta = null) {
            if (!currentVideo || !editorState.zone) return;
            const zoneName = editorState.zone;
            const prevCount = (editorState.zones?.[zoneName]?.polygons || []).length;
            const res = await fetch('/api/zones', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: zoneName, polygons: [poly], video: currentVideo })
            });
            if (!res.ok) throw new Error('POST zone failed');
            setDrawType(currentVideo, zoneName, prevCount, type);
            if (type === 'line' && extraMeta) {
                setLineMeta(currentVideo, zoneName, prevCount, extraMeta);
            }
            // refresh editor state from server
            const [zonesRes, presenceRes] = await Promise.all([
                fetch(`/api/zones/${encodeURIComponent(currentVideo)}`),
                fetch(`/api/presence/${encodeURIComponent(currentVideo)}`)
            ]);
            const zdata = await zonesRes.json();
            const pdata = await presenceRes.json();
            editorState.zones = zdata.zones || {};
            editorState.presence = pdata.zones || {};
            // UX: après création, on sélectionne automatiquement la nouvelle forme pour pouvoir l'ajuster
            editorSetTool('select');
            editorState.zone = zoneName;
            editorState.polygonIdx = prevCount;
            editorRenderZoneList();
            editorRender();
            try { await refreshMainAfterEditor(true); } catch {}
        }

        async function refreshMainAfterEditor(force = false) {
            // Soft refresh (sans recharger la page) pour éviter de perdre l'état multi-site (in-memory)
            if (!currentVideo) return;
            // Force invalidation defs (très important après sauvegarde/suppression)
            if (force) {
                try {
                    zonesDefsFetchedByVideo[currentVideo] = false;
                    zonesDefsFetchTsByVideo[currentVideo] = 0;
                    zonesCacheRefreshTs = 0;
                } catch {}
            }

            // refresh KPI / sidebar
            await refreshZonesCacheForSite(true);
            await loadZones();

            // IMPORTANT: s'assurer que l'UI principale repasse bien en "frame + overlay" si la détection est stoppée en éditant
            if (!isCurrentVideoStreaming) {
                videoStream.src = '';
                videoStream.classList.add('hidden');
                videoFrame.classList.remove('hidden');
                drawCanvas.classList.remove('hidden');

                // refresh frame (cache-bust) + redraw overlay *après* chargement image
                videoFrame.onload = async () => {
                    syncCanvasSize();
                    try { await drawExistingZones(true); } catch {}
                };
                videoFrame.src = `/api/videos/${encodeURIComponent(currentVideo)}/frame?t=${Date.now()}`;
            } else {
                // si stream: on ne redessine pas l'overlay (canvas masqué), mais on garde l'UI à jour
                try { await drawExistingZones(false); } catch {}
            }
        }

        function editorSelectZone(zoneName) {
            editorState.zone = zoneName;
            editorState.polygonIdx = null;
            editorState.mode = 'idle';
            editorState.points = [];
            editorRenderZoneList();
            editorRender();
        }

        function editorRenderZoneList() {
            const zones = editorState.zones || {};
            const presence = editorState.presence || {};
            const keys = Object.keys(zones).sort((a,b) => a.localeCompare(b));
            editorZoneList.innerHTML = keys.length
                ? keys.map((z) => {
                    const info = presence[z] || { formatted_time: '00:00:00' };
                    const active = editorState.zone === z ? 'active' : '';
                    const count = (zones[z]?.polygons || []).length;
                    return `
                        <div class="editor-zone-row ${active}" onclick="window.__editorSelectZone('${z.replace(/'/g, "\\'")}')">
                            <div class="editor-zone-left">
                                <span class="editor-dot"></span>
                                <span class="editor-zone-name">${z}</span>
                            </div>
                            <span class="editor-zone-meta">${info.formatted_time} • ${count}</span>
                        </div>
                    `;
                }).join('')
                : `<div style="color: rgba(245,247,255,0.65); font-size: var(--text-sm);">Aucune zone</div>`;
        }

        window.__editorSelectZone = (z) => editorSelectZone(z);

        async function editorDeleteZone() {
            if (!currentVideo || !editorState.zone) {
                uiAlert('Sélectionnez une zone à supprimer.', 'Zones');
                return;
            }
            const zoneName = editorState.zone;
            const ok = await uiConfirm(`Supprimer la zone "${zoneName}" (tous ses dessins) ?`, 'Suppression');
            if (!ok) return;

            const res = await fetch(`/api/zones/${encodeURIComponent(currentVideo)}/${encodeURIComponent(zoneName)}`, { method: 'DELETE' });
            if (!res.ok) {
                uiAlert('Erreur suppression zone.', 'Suppression');
                return;
            }

            // Refresh editor + main UI
            editorState.zone = null;
            editorState.polygonIdx = null;
            hideHoverBar();
            await editorOpen();
            try { await loadZones(); await drawExistingZones(); } catch {}
        }

        async function editorOpen() {
            if (!currentVideo) {
                uiAlert('Choisissez une caméra avant de dessiner.', 'Dessin');
                return;
            }
            if (isCurrentVideoStreaming) {
                // On stoppe pour éditer sur frame fixe (plus fiable)
                await fetch(`/api/stream/${encodeURIComponent(currentVideo)}/stop`, { method: 'POST' });
                isCurrentVideoStreaming = false;
            }

            const cam = getCameraByVideo(currentVideo);
            editorTitle.textContent = `Video Editing — ${cam ? cam.name : currentVideo}`;
            editorSubtitle.textContent = `Source: ${currentVideo}`;

            // Load info + zones
            const [infoRes, zonesRes, presenceRes] = await Promise.all([
                fetch(`/api/videos/${encodeURIComponent(currentVideo)}/info`),
                fetch(`/api/zones/${encodeURIComponent(currentVideo)}`),
                fetch(`/api/presence/${encodeURIComponent(currentVideo)}`)
            ]);
            const info = await infoRes.json();
            const zdata = await zonesRes.json();
            const pdata = await presenceRes.json();

            editorState.w = info.width;
            editorState.h = info.height;
            editorState.zones = zdata.zones || {};
            editorState.presence = pdata.zones || {};
            if (!editorState.zone) {
                const firstZone = Object.keys(editorState.zones)[0] || null;
                editorState.zone = firstZone;
            }

            editorCamId.textContent = cam ? cam.id : '—';
            editorCamSource.textContent = currentVideo;
            editorCamRes.textContent = `${info.width}×${info.height}`;
            editorCamStatus.textContent = 'Online';

            editorFrame.src = `/api/videos/${encodeURIComponent(currentVideo)}/frame?t=${Date.now()}`;
            editorCanvas.width = info.width;
            editorCanvas.height = info.height;

            editorSetTool('select');
            editorClearTemp();
            editorRenderZoneList();

            editorOverlay.classList.remove('hidden');
            editorState.open = true;
            // sync canvas display size after image load
            editorFrame.onload = () => {
                const r = editorFrame.getBoundingClientRect();
                editorCanvas.style.width = r.width + 'px';
                editorCanvas.style.height = r.height + 'px';
                editorRender();
            };
        }

        function editorClose() {
            editorOverlay.classList.add('hidden');
            editorState.open = false;
            editorClearTemp();
            // Important: quand on quitte l'éditeur, on force un refresh visuel (évite l'impression que les anciennes formes “persistaient”)
            refreshMainAfterEditor(true).catch(() => {});
        }

        function editorRender() {
            // clear
            editorCtx.clearRect(0, 0, editorCanvas.width, editorCanvas.height);

            // draw existing drawings for all zones (selected zone full, others ghosted)
            const selectedZone = editorState.zone;
            const zonesObj = editorState.zones || {};
            const zoneKeys = Object.keys(zonesObj).sort((a, b) => a.localeCompare(b));
            zoneKeys.forEach((zoneName) => {
                const polys = zonesObj?.[zoneName]?.polygons || [];
                const isGhost = !!(selectedZone && zoneName !== selectedZone);
                const prevAlpha = editorCtx.globalAlpha;
                editorCtx.globalAlpha = isGhost ? 0.22 : 1;

                polys.forEach((poly, idx) => {
                    if (!poly || poly.length < 3) return;
                    const isActive = (!isGhost) && (editorState.polygonIdx === idx);
                    const type = getDrawType(currentVideo, zoneName, idx);
                    const c = colorsForType(type, isActive);

                    if (type === 'line' && poly.length === 4) {
                        // Render backend quadrilateral as a center line (editor view)
                        const a = [(poly[0][0] + poly[1][0]) / 2, (poly[0][1] + poly[1][1]) / 2];
                        const b = [(poly[2][0] + poly[3][0]) / 2, (poly[2][1] + poly[3][1]) / 2];
                        editorCtx.beginPath();
                        editorCtx.moveTo(a[0], a[1]);
                        editorCtx.lineTo(b[0], b[1]);
                        editorCtx.strokeStyle = c.stroke;
                        editorCtx.lineWidth = isActive ? 4 : (isGhost ? 1.6 : 2);
                        editorCtx.setLineDash([]);
                        editorCtx.stroke();

                        // Arrow: show on active line with handle; show ghost arrow without handle
                        const meta = getLineMeta(currentVideo, zoneName, idx);
                        const arrow = computeLineArrowFromMeta(meta, poly);
                        if (arrow?.mid && arrow?.end) {
                            drawArrow(
                                editorCtx,
                                arrow.mid,
                                arrow.end,
                                c.stroke,
                                { shaftWidth: isGhost ? 1.4 : 2, dashed: false, head: 22, wing: 13, outline: true, handle: !isGhost }
                            );
                        }
                    } else {
                        editorCtx.beginPath();
                        editorCtx.moveTo(poly[0][0], poly[0][1]);
                        for (let i = 1; i < poly.length; i++) editorCtx.lineTo(poly[i][0], poly[i][1]);
                        editorCtx.closePath();
                        editorCtx.fillStyle = c.fill;
                        editorCtx.fill();
                        editorCtx.strokeStyle = c.stroke;
                        editorCtx.lineWidth = isActive ? 4 : (isGhost ? 1.6 : 2);
                        editorCtx.stroke();
                    }
                });

                editorCtx.globalAlpha = prevAlpha;
            });

            // draw current temp tool
            if (editorState.points.length) {
                if (editorState.tool === 'line') {
                    const p1 = editorState.points[0];
                    const p2 = editorState.points[1];
                    if (p1) {
                        editorCtx.beginPath();
                        editorCtx.arc(p1[0], p1[1], 8, 0, Math.PI * 2);
                        editorCtx.fillStyle = '#10B0F9';
                        editorCtx.fill();
                    }
                    if (p2) {
                        editorCtx.beginPath();
                        editorCtx.arc(p2[0], p2[1], 8, 0, Math.PI * 2);
                        editorCtx.fillStyle = '#10B0F9';
                        editorCtx.fill();
                        editorCtx.beginPath();
                        editorCtx.moveTo(p1[0], p1[1]);
                        editorCtx.lineTo(p2[0], p2[1]);
                        editorCtx.strokeStyle = '#10B0F9';
                        editorCtx.lineWidth = 2; /* plus fin */
                        editorCtx.setLineDash([]); /* continu */
                        editorCtx.stroke();
                        editorCtx.setLineDash([]);
                    }
                    // Flèche de direction depuis le centre (seulement quand on a 2 points)
                    if (p1 && p2) {
                        const mid = [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2];
                        const def = getLineDraftMidAndDefaultDir();
                        const end = editorState.lineDirEnd || def?.end;
                        if (end) drawArrow(editorCtx, mid, end, '#10B0F9', { shaftWidth: 2, dashed: false, head: 22, wing: 13, outline: true });
                    }
                } else if (editorState.tool === 'include' || editorState.tool === 'exclude') {
                    const pts = editorState.points;
                    const t = editorState.tool === 'exclude' ? 'exclude' : 'include';
                    const c = colorsForType(t, false);
                    editorCtx.beginPath();
                    editorCtx.moveTo(pts[0][0], pts[0][1]);
                    for (let i = 1; i < pts.length; i++) editorCtx.lineTo(pts[i][0], pts[i][1]);
                    if (pts.length >= 3) {
                        editorCtx.closePath();
                        editorCtx.fillStyle = c.fill;
                        editorCtx.fill();
                    }
                    editorCtx.strokeStyle = c.stroke;
                    editorCtx.lineWidth = 3;
                    editorCtx.setLineDash([6, 4]);
                    editorCtx.stroke();
                    editorCtx.setLineDash([]);

                    pts.forEach((p, i) => {
                        editorCtx.beginPath();
                        editorCtx.arc(p[0], p[1], 8, 0, Math.PI * 2);
                        editorCtx.fillStyle = i === 0 ? '#10B0F9' : '#22c55e';
                        editorCtx.fill();
                        editorCtx.strokeStyle = '#000';
                        editorCtx.lineWidth = 2;
                        editorCtx.stroke();
                    });
                }
            }

            // draw handles for selected polygon (edit)
            if (editorState.tool === 'select' && editorState.zone && typeof editorState.polygonIdx === 'number') {
                const poly = editorState.zones?.[editorState.zone]?.polygons?.[editorState.polygonIdx];
                if (poly && poly.length) {
                    const type = getDrawType(currentVideo, editorState.zone, editorState.polygonIdx);
                    if (type === 'line' && poly.length === 4) {
                        const ends = lineEndpointsFromQuad(poly);
                        const pts = ends ? [ends.p1, ends.p2] : [];
                        pts.forEach((p) => {
                            editorCtx.beginPath();
                            editorCtx.arc(p[0], p[1], 9, 0, Math.PI * 2);
                            editorCtx.fillStyle = '#10B0F9';
                            editorCtx.fill();
                            editorCtx.strokeStyle = '#fff';
                            editorCtx.lineWidth = 2;
                            editorCtx.stroke();
                        });
                    } else {
                        poly.forEach((p) => {
                            editorCtx.beginPath();
                            editorCtx.arc(p[0], p[1], 9, 0, Math.PI * 2);
                            editorCtx.fillStyle = '#10B0F9';
                            editorCtx.fill();
                            editorCtx.strokeStyle = '#fff';
                            editorCtx.lineWidth = 2;
                            editorCtx.stroke();
                        });
                    }
                }
            }
        }

        let hoverHideTimer = null;
        let hoverKey = '';

        function cancelHoverHide() {
            if (hoverHideTimer) clearTimeout(hoverHideTimer);
            hoverHideTimer = null;
        }

        function scheduleHoverHide(ms = 7000) {
            cancelHoverHide();
            // Ne pas auto-masquer si déjà caché
            if (editorHoverBar.classList.contains('hidden')) return;
            hoverHideTimer = setTimeout(() => {
                hideHoverBar();
            }, ms);
        }

        function hideHoverBar() {
            cancelHoverHide();
            editorHoverBar.classList.add('hidden');
            editorHoverBar.dataset.kind = '';
            editorHoverBar.dataset.vIdx = '';
            hoverKey = '';
        }

        function showHoverBar(xCss, yCss, kind, vIdx, key, avoidX = xCss, avoidY = yCss) {
            // Le hoverbar ne doit JAMAIS obstruer le point (sinon impossible de le déplacer),
            // y compris quand on est près des bords (clamp).
            editorHoverBar.classList.remove('hidden');
            editorHoverBar.dataset.kind = kind;
            editorHoverBar.dataset.vIdx = typeof vIdx === 'number' ? String(vIdx) : '';
            // Suppression de point uniquement sur sommet de polygone (pas sur extrémités de ligne)
            hoverDeletePointBtn.classList.toggle('hidden', kind !== 'vertex');
            hoverKey = key || '';

            // Mesure réelle (selon si le bouton "point" est visible ou non)
            const barW = editorHoverBar.offsetWidth || 92;
            const barH = editorHoverBar.offsetHeight || 46;

            // Bounds: canvas wrap (coordonnées CSS)
            const wrapRect = editorCanvas.getBoundingClientRect();
            const maxLeft = Math.max(0, wrapRect.width - barW);
            const maxTop = Math.max(0, wrapRect.height - barH);

            // Zone interdite autour du point (évite le recouvrement)
            const avoid = 44; // px CSS (généreux)
            const ax1 = avoidX - avoid, ay1 = avoidY - avoid;
            const ax2 = avoidX + avoid, ay2 = avoidY + avoid;

            function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
            function noOverlap(l, t) {
                const r = l + barW, b = t + barH;
                // pas d'intersection avec le carré d'évitement
                return (r < ax1) || (l > ax2) || (b < ay1) || (t > ay2);
            }

            function overlapArea(l, t) {
                const r = l + barW, b = t + barH;
                const ox = Math.max(0, Math.min(r, ax2) - Math.max(l, ax1));
                const oy = Math.max(0, Math.min(b, ay2) - Math.max(t, ay1));
                return ox * oy;
            }

            // Essaye plusieurs positions autour du point (8 directions), puis on choisit le moindre chevauchement.
            const off = 12;
            const candidates = [
                { l: avoidX + off, t: avoidY - barH - off },                 // NE
                { l: avoidX + off, t: avoidY + off },                        // SE
                { l: avoidX - barW - off, t: avoidY - barH - off },          // NW
                { l: avoidX - barW - off, t: avoidY + off },                 // SW
                { l: avoidX - barW / 2, t: avoidY - barH - off },            // N
                { l: avoidX - barW / 2, t: avoidY + off },                   // S
                { l: avoidX + off, t: avoidY - barH / 2 },                   // E
                { l: avoidX - barW - off, t: avoidY - barH / 2 },            // W
            ];

            let placed = null;
            let best = null;
            for (const c of candidates) {
                const l = clamp(c.l, 0, maxLeft);
                const t = clamp(c.t, 0, maxTop);
                if (noOverlap(l, t)) { placed = { l, t }; break; }
                const a = overlapArea(l, t);
                if (!best || a < best.a) best = { l, t, a };
            }
            // Fallback: position la moins mauvaise (chevauchement minimal) plutôt que de recouvrir le point
            if (!placed && best) placed = { l: best.l, t: best.t };
            if (!placed) placed = { l: clamp(avoidX + off, 0, maxLeft), t: clamp(avoidY + off, 0, maxTop) };

            editorHoverBar.style.left = `${placed.l}px`;
            editorHoverBar.style.top = `${placed.t}px`;
            // Persistance généreuse (7s) pour permettre le déplacement de la souris + clic
            scheduleHoverHide(7000);
        }

        function editorEventPoint(e) {
            const rect = editorCanvas.getBoundingClientRect();
            const scaleX = editorCanvas.width / rect.width;
            const scaleY = editorCanvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            return [x, y];
        }

        function pointInPoly(poly, p) {
            // ray casting
            let inside = false;
            for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
                const xi = poly[i][0], yi = poly[i][1];
                const xj = poly[j][0], yj = poly[j][1];
                const intersect = ((yi > p[1]) !== (yj > p[1])) &&
                    (p[0] < (xj - xi) * (p[1] - yi) / (yj - yi + 1e-9) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        function editorPickPolygon(p) {
            const zoneName = editorState.zone;
            const polys = editorState.zones?.[zoneName]?.polygons || [];
            for (let idx = polys.length - 1; idx >= 0; idx--) {
                const poly = polys[idx];
                if (poly?.length >= 3 && pointInPoly(poly, p)) return idx;
            }
            return null;
        }

        function editorNearestVertex(poly, p, radius = 32) {
            let best = -1;
            let bestD = Infinity;
            for (let i = 0; i < poly.length; i++) {
                const d = dist2(poly[i], p);
                if (d < bestD) { bestD = d; best = i; }
            }
            return bestD <= radius * radius ? best : -1;
        }

        function lineEndpointsFromQuad(poly) {
            if (!poly || poly.length !== 4) return null;
            const a = [(poly[0][0] + poly[1][0]) / 2, (poly[0][1] + poly[1][1]) / 2];
            const b = [(poly[2][0] + poly[3][0]) / 2, (poly[2][1] + poly[3][1]) / 2];
            return { p1: a, p2: b };
        }

        function editorNearestLineEndpoint(poly, p, radius = 34) {
            const ends = lineEndpointsFromQuad(poly);
            if (!ends) return -1;
            const d1 = dist2(ends.p1, p);
            const d2 = dist2(ends.p2, p);
            const r2 = radius * radius;
            if (d1 <= r2 && d1 <= d2) return 0;
            if (d2 <= r2) return 1;
            return -1;
        }

        function editorUpdateHoverUI(e) {
            if (!editorState.open) return;
            if (editorState.tool !== 'select') {
                hideHoverBar();
                return;
            }
            const zoneName = editorState.zone;
            if (!zoneName) { scheduleHoverHide(7000); return; }
            const p = editorEventPoint(e);
            const idx = editorPickPolygon(p);
            if (idx === null) { scheduleHoverHide(7000); return; }

            // Prefer hovered polygon as selected (lightweight)
            editorState.polygonIdx = idx;
            const poly = editorState.zones?.[zoneName]?.polygons?.[idx];
            if (!poly) { scheduleHoverHide(7000); return; }
            const type = getDrawType(currentVideo, zoneName, idx);
            const lineEnd = (type === 'line' && poly.length === 4) ? editorNearestLineEndpoint(poly, p, 34) : -1;
            const vIdx = (lineEnd >= 0) ? -1 : editorNearestVertex(poly, p, 34);

            const wrapRect = editorCanvas.getBoundingClientRect();
            const kind = (lineEnd >= 0) ? 'lineEnd' : (vIdx >= 0 ? 'vertex' : 'poly');
            const key =
                kind === 'lineEnd'
                    ? `${idx}:le${lineEnd}`
                    : `${idx}:${kind === 'vertex' ? `v${vIdx}` : 'p'}`;

            // IMPORTANT UX:
            // - Le hoverbar doit rester "ancré" (pas suivre la souris) pour pouvoir cliquer dessus.
            // - On ne repositionne que si la cible change.
            if (key !== hoverKey) {
                let xCss = 0;
                let yCss = 0;

                if (kind === 'lineEnd') {
                    const ends = lineEndpointsFromQuad(poly);
                    if (!ends) { scheduleHoverHide(7000); return; }
                    const end = lineEnd === 0 ? ends.p1 : ends.p2;
                    const scaleX = wrapRect.width / editorCanvas.width;
                    const scaleY = wrapRect.height / editorCanvas.height;
                    const px = end[0] * scaleX;
                    const py = end[1] * scaleY;
                    showHoverBar(px, py, kind, lineEnd, key, px, py);
                    editorRender();
                    return;
                } else if (kind === 'vertex') {
                    // Anchor on vertex position (canvas coords -> CSS coords)
                    const vx = poly[vIdx][0];
                    const vy = poly[vIdx][1];
                    const scaleX = wrapRect.width / editorCanvas.width;
                    const scaleY = wrapRect.height / editorCanvas.height;
                    // Important: éviter le vrai point (pas un point décalé), sinon au bord le clamp peut le recouvrir.
                    const px = vx * scaleX;
                    const py = vy * scaleY;
                    xCss = px;
                    yCss = py;
                    // avoidX/avoidY = centre du point
                    showHoverBar(xCss, yCss, kind, kind === 'vertex' ? vIdx : null, key, px, py);
                    // showHoverBar déjà appelé, on sort
                    editorRender();
                    return;
                } else {
                    // Anchor near initial hover position (cursor at the time), but do not track afterwards
                    xCss = (e.clientX - wrapRect.left) + 10;
                    yCss = (e.clientY - wrapRect.top) + 10;
                }

                // showHoverBar gère clamp + évitement du point, donc on lui passe le point d'ancrage brut
                showHoverBar(
                    xCss,
                    yCss,
                    kind,
                    kind === 'vertex' ? vIdx : null,
                    key
                );
            } else {
                // Keep alive while hovering same target
                scheduleHoverHide(7000);
            }
            editorRender();
        }

        editorCanvas.addEventListener('dblclick', (e) => {
            if (!editorState.open) return;
            // IMPORTANT UX: pas d’auto-save au double-clic (trop “surprenant”).
            // Le flow fiable: dessiner → cliquer "Sauver".
            e.preventDefault();
        });

        editorCanvas.addEventListener('pointerdown', (e) => {
            if (!editorState.open) return;
            const p = editorEventPoint(e);

            if (editorState.tool === 'line') {
                // Ligne de comptage: 2 points strict.
                // - si déjà 2 points: clic sur la poignée flèche => drag direction, sinon redémarre une nouvelle ligne
                if (editorState.points.length === 2) {
                    const p1 = editorState.points[0];
                    const p2 = editorState.points[1];
                    const mid = [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2];
                    const def = getLineDraftMidAndDefaultDir();
                    const end = editorState.lineDirEnd || def?.end;
                    if (end && lineHandleHit(p, end)) {
                        editorState.drag = { kind: 'lineDir' };
                        editorState.didDrag = false;
                        editorCanvas.setPointerCapture(e.pointerId);
                        editorRender();
                        return;
                    }
                    // redémarre
                    editorPushUndo();
                    editorState.points = [p];
                    editorState.lineDirEnd = null;
                    editorRender();
                    return;
                }
                editorPushUndo();
                editorState.points.push(p);
                // dès qu'on a 2 points, initialise une direction par défaut
                if (editorState.points.length === 2) {
                    const def = getLineDraftMidAndDefaultDir();
                    if (def?.end) editorState.lineDirEnd = def.end;
                }
                editorRender();
                return;
            }

            if (editorState.tool === 'include' || editorState.tool === 'exclude') {
                editorPushUndo();
                editorState.points.push(p);
                editorRender();
                return;
            }

            // select/edit
            const zoneName = editorState.zone;
            if (!zoneName) return;
            const idx = editorPickPolygon(p);
            if (idx === null) {
                editorState.polygonIdx = null;
                hideHoverBar();
                editorRender();
                return;
            }
            editorState.polygonIdx = idx;
            hideHoverBar();

            const poly = editorState.zones[zoneName].polygons[idx];
            // Ligne de comptage sélectionnée: drag la flèche de direction (sans toucher aux points)
            if (getDrawType(currentVideo, zoneName, idx) === 'line') {
                const meta = getLineMeta(currentVideo, zoneName, idx);
                const arrow = computeLineArrowFromMeta(meta, poly);
                if (arrow?.end && lineHandleHit(p, arrow.end)) {
                    editorPushUndo();
                    editorState.drag = { kind: 'lineDirSaved', zoneName, idx, mid: arrow.mid };
                    editorState.didDrag = false;
                    editorCanvas.setPointerCapture(e.pointerId);
                    editorRender();
                    return;
                }
            }
            const type = getDrawType(currentVideo, zoneName, idx);
            if (type === 'line' && poly.length === 4) {
                // Ligne = forme entière: on autorise uniquement
                // - drag du segment (déplacement global)
                // - drag d'une extrémité (2 poignées)
                const ends = lineEndpointsFromQuad(poly);
                const endIdx = editorNearestLineEndpoint(poly, p, 34);
                if (endIdx >= 0 && ends) {
                    const meta = getLineMeta(currentVideo, zoneName, idx) || {};
                    const p1 = Array.isArray(meta.p1) ? meta.p1 : ends.p1;
                    const p2 = Array.isArray(meta.p2) ? meta.p2 : ends.p2;
                    editorPushUndo();
                    editorState.drag = {
                        kind: 'lineEnd',
                        zoneName,
                        idx,
                        endIdx,
                        other: endIdx === 0 ? p2 : p1,
                        dir: Array.isArray(meta.dir) ? meta.dir : null
                    };
                    editorState.didDrag = false;
                    editorCanvas.setPointerCapture(e.pointerId);
                } else {
                    editorPushUndo();
                    editorState.drag = { kind: 'poly', start: p };
                    editorState.didDrag = false;
                    editorCanvas.setPointerCapture(e.pointerId);
                }
            } else {
                const vIdx = editorNearestVertex(poly, p, 34);
                if (vIdx >= 0) {
                    editorPushUndo();
                    editorState.drag = { kind: 'vertex', vIdx };
                    editorState.didDrag = false;
                    editorCanvas.setPointerCapture(e.pointerId);
                } else {
                    // insertion de point sur arête: volontaire (Shift) pour éviter les insertions accidentelles
                    const copy = clonePointsArray(editorState.zones[zoneName].polygons);
                    const polyCopy = copy[idx];
                    const inserted = e.shiftKey ? insertPointOnNearestEdge(polyCopy, p) : false;
                    if (inserted) {
                        editorPushUndo();
                        editorState.zones[zoneName].polygons = copy;
                        editorScheduleAutosave();
                    } else {
                        editorPushUndo();
                        editorState.drag = { kind: 'poly', start: p };
                        editorState.didDrag = false;
                        editorCanvas.setPointerCapture(e.pointerId);
                    }
                }
            }
            editorRender();
        });

        editorCanvas.addEventListener('pointermove', (e) => {
            if (!editorState.open) return;
            if (!editorState.drag) {
                editorUpdateHoverUI(e);
                return;
            }
            if (editorState.drag.kind === 'lineDir' && editorState.tool === 'line' && editorState.points.length === 2) {
                const p = editorEventPoint(e);
                const p1 = editorState.points[0];
                const p2 = editorState.points[1];
                const mid = [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2];
                const v = sub(p, mid);
                // évite une flèche trop courte
                if (Math.hypot(v[0], v[1]) > 8) {
                    editorState.lineDirEnd = p;
                    editorState.didDrag = true;
                }
                editorRender();
                return;
            }
            if (editorState.drag.kind === 'lineDirSaved') {
                const p = editorEventPoint(e);
                const zoneName = editorState.drag.zoneName;
                const idx = editorState.drag.idx;
                const mid = editorState.drag.mid;
                if (!zoneName || typeof idx !== 'number' || !mid) return;
                const v = sub(p, mid);
                if (Math.hypot(v[0], v[1]) > 8) {
                    const d = norm(v);
                    const meta = getLineMeta(currentVideo, zoneName, idx) || {};
                    // conserve p1/p2 si déjà présents
                    meta.dir = d;
                    setLineMeta(currentVideo, zoneName, idx, meta);
                    editorState.didDrag = true;
                }
                editorRender();
                return;
            }
            if (editorState.drag.kind === 'lineEnd') {
                const p = editorEventPoint(e);
                const zoneName = editorState.drag.zoneName;
                const idx = editorState.drag.idx;
                const other = editorState.drag.other;
                const endIdx = editorState.drag.endIdx;
                if (!zoneName || typeof idx !== 'number' || !other || (endIdx !== 0 && endIdx !== 1)) return;

                const p1 = endIdx === 0 ? [p[0], p[1]] : [other[0], other[1]];
                const p2 = endIdx === 1 ? [p[0], p[1]] : [other[0], other[1]];
                const newPoly = lineToPolygon(p1, p2, 12);
                const poly = editorState.zones?.[zoneName]?.polygons?.[idx];
                if (poly) editorState.zones[zoneName].polygons[idx] = newPoly;

                const meta = getLineMeta(currentVideo, zoneName, idx) || {};
                meta.p1 = p1;
                meta.p2 = p2;
                if (editorState.drag.dir) meta.dir = editorState.drag.dir;
                setLineMeta(currentVideo, zoneName, idx, meta);

                editorState.didDrag = true;
                editorRender();
                return;
            }
            const zoneName = editorState.zone;
            if (!zoneName || typeof editorState.polygonIdx !== 'number') return;
            const p = editorEventPoint(e);
            // Perf: ne pas cloner à chaque move (ça rendait le drag "mou").
            const poly = editorState.zones?.[zoneName]?.polygons?.[editorState.polygonIdx];
            if (!poly) return;

            if (editorState.drag.kind === 'vertex') {
                const vIdx = editorState.drag.vIdx;
                if (typeof vIdx !== 'number' || !poly[vIdx]) return;
                poly[vIdx] = [p[0], p[1]];
                editorState.didDrag = true;
            } else if (editorState.drag.kind === 'poly') {
                const start = editorState.drag.start;
                if (!start) return;
                const dx = p[0] - start[0];
                const dy = p[1] - start[1];
                // Si c'est une ligne: on déplace la forme entière ET on translate le linemeta p1/p2
                try {
                    const idx = editorState.polygonIdx;
                    const type = getDrawType(currentVideo, zoneName, idx);
                    if (type === 'line' && poly.length === 4) {
                        const meta = getLineMeta(currentVideo, zoneName, idx) || {};
                        if (Array.isArray(meta.p1)) meta.p1 = [meta.p1[0] + dx, meta.p1[1] + dy];
                        if (Array.isArray(meta.p2)) meta.p2 = [meta.p2[0] + dx, meta.p2[1] + dy];
                        setLineMeta(currentVideo, zoneName, idx, meta);
                    }
                } catch {}
                for (let i = 0; i < poly.length; i++) {
                    poly[i] = [poly[i][0] + dx, poly[i][1] + dy];
                }
                editorState.drag.start = p;
                editorState.didDrag = true;
            }
            editorRender();
        });

        editorCanvas.addEventListener('pointerup', () => {
            if (!editorState.open) return;
            const dragKind = editorState.drag?.kind;
            editorState.drag = null;
            if (editorState.didDrag) {
                editorState.didDrag = false;
                // Ne pas autosave (PUT) quand on ne fait que tirer la flèche direction (meta localStorage).
                if (dragKind !== 'lineDir' && dragKind !== 'lineDirSaved') {
                    editorScheduleAutosave();
                }
            }
        });

        async function editorCommitDraftShape() {
            // Toolbar "Sauvegarder": confirme la forme actuellement tracée (draft -> forme)
            if (!currentVideo) {
                uiAlert('Choisissez une caméra avant de dessiner.', 'Sauvegarde');
                return;
            }
            // UX: si aucune zone n'est sélectionnée mais qu'il en existe, on en choisit une automatiquement.
            if (!editorState.zone) {
                const keys = Object.keys(editorState.zones || {}).sort();
                if (keys.length >= 1) {
                    editorSelectZone(keys[0]);
                } else {
                    uiAlert('Créez d’abord une zone à droite (bouton +), puis cliquez sur “Sauvegarder”.', 'Sauvegarde');
                    try { editorNewZoneName?.focus(); } catch {}
                    return;
                }
            }

            // Commit seulement si un tracé est en cours
            if (editorState.tool === 'line' && editorState.points.length === 2) {
                const p1 = editorState.points[0];
                const p2 = editorState.points[1];
                const poly = lineToPolygon(p1, p2, 12);
                const mid = [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2];
                const end = editorState.lineDirEnd || getLineDraftMidAndDefaultDir()?.end || add(mid, [0, -60]);
                const d = norm(sub(end, mid));
                const meta = { p1, p2, dir: d };
                editorState.points = [];
                editorState.lineDirEnd = null;
                editorRender();
                await editorPostNewPolygon('line', poly, meta);
                return;
            }

            if ((editorState.tool === 'include' || editorState.tool === 'exclude') && editorState.points.length >= 3) {
                const poly = clonePoints(editorState.points);
                const type = editorState.tool === 'exclude' ? 'exclude' : 'include';
                editorState.points = [];
                editorRender();
                await editorPostNewPolygon(type, poly);
                return;
            }

            uiAlert('Aucune forme en cours de tracé à sauvegarder.', 'Sauvegarde');
        }

        async function editorSaveAll() {
            // Bouton "Sauvegarder tout" (bas): sauvegarde la configuration entière (PUT)
            if (!currentVideo) {
                uiAlert('Choisissez une caméra avant de sauvegarder.', 'Sauvegarde');
                return;
            }
            if (!editorState.zone) {
                const keys = Object.keys(editorState.zones || {}).sort();
                if (keys.length >= 1) editorSelectZone(keys[0]);
            }
            try {
                await editorPutNow();
                const [zonesRes, presenceRes] = await Promise.all([
                    fetch(`/api/zones/${encodeURIComponent(currentVideo)}`),
                    fetch(`/api/presence/${encodeURIComponent(currentVideo)}`)
                ]);
                const zdata = await zonesRes.json();
                const pdata = await presenceRes.json();
                editorState.zones = zdata.zones || {};
                editorState.presence = pdata.zones || {};
                editorRenderZoneList();
                editorRender();
                await refreshMainAfterEditor(true);
            } catch (e) {
                uiAlert('Erreur: sauvegarde (PUT).', 'Sauvegarde');
            }
        }

        editorAddZoneBtn.addEventListener('click', async () => {
            const name = editorNewZoneName.value.trim();
            if (!name) return;
            const res = await fetch('/api/zones', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name, polygons: [], video: currentVideo })
            });
            if (!res.ok) { uiAlert('Erreur création zone', 'Zones'); return; }
            editorNewZoneName.value = '';
            await editorOpen(); // refresh editor state
            editorSelectZone(name);
        });

        editorDeleteZoneBtn?.addEventListener('click', editorDeleteZone);

        toolSelectBtn.addEventListener('click', () => editorSetTool('select'));
        toolCountLineBtn.addEventListener('click', () => { editorSetTool('line'); editorState.points = []; editorRender(); });
        toolIncludeBtn.addEventListener('click', () => { editorSetTool('include'); editorState.points = []; editorRender(); });
        toolExcludeBtn.addEventListener('click', () => { editorSetTool('exclude'); editorState.points = []; editorRender(); });
        toolUndoBtn.addEventListener('click', () => {
            // Annulation “intelligente” façon paint:
            // - si on trace, on retire le dernier point
            // - sinon on annule le dernier snapshot
            if ((editorState.tool === 'include' || editorState.tool === 'exclude' || editorState.tool === 'line') && editorState.points.length) {
                editorState.points.pop();
                editorRender();
                return;
            }
            editorPopUndo();
        });
        toolClearBtn.addEventListener('click', () => { editorPushUndo(); editorClearTemp(); });
        toolSaveBtn?.addEventListener('click', editorCommitDraftShape);

        editorSaveBtn.addEventListener('click', editorSaveAll);
        editorCloseBtn.addEventListener('click', editorClose);
        editorCloseBtn2?.addEventListener('click', editorClose);

        // Hoverbar: keep it clickable (pause auto-hide while hovering it)
        editorHoverBar?.addEventListener('pointerenter', cancelHoverHide);
        editorHoverBar?.addEventListener('pointerleave', () => scheduleHoverHide(7000));

        // Hover actions
        hoverDeletePointBtn.addEventListener('click', () => {
            if (!editorState.zone || typeof editorState.polygonIdx !== 'number') return;
            const kind = editorHoverBar.dataset.kind;
            const vIdx = Number(editorHoverBar.dataset.vIdx);
            if (kind !== 'vertex' || !Number.isFinite(vIdx)) return;
            const copy = clonePointsArray(editorState.zones?.[editorState.zone]?.polygons || []);
            const poly = copy[editorState.polygonIdx];
            if (!poly || poly.length <= 3) {
                uiAlert('Un polygone doit garder au moins 3 points.', 'Edition');
                return;
            }
            editorPushUndo();
            poly.splice(vIdx, 1);
            editorState.zones[editorState.zone].polygons = copy;
            editorScheduleAutosave();
            hideHoverBar();
            editorRender();
        });

        hoverDeleteShapeBtn.addEventListener('click', async () => {
            if (!editorState.zone || typeof editorState.polygonIdx !== 'number') return;
            const copy = clonePointsArray(editorState.zones?.[editorState.zone]?.polygons || []);
            if (!copy[editorState.polygonIdx]) return;
            const ok = await uiConfirm('Supprimer ce dessin ?', 'Suppression');
            if (!ok) return;
            editorPushUndo();
            copy.splice(editorState.polygonIdx, 1);
            editorState.zones[editorState.zone].polygons = copy;
            editorState.polygonIdx = null;
            editorScheduleAutosave();
            hideHoverBar();
            editorRenderZoneList();
            editorRender();
        });

        // Raccourcis clavier (paint-like)
        document.addEventListener('keydown', (e) => {
            if (!editorState.open) return;
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
                e.preventDefault();
                toolUndoBtn.click();
            }
            if (e.key === 'Escape') {
                e.preventDefault();
                editorClose();
            }
        });

        // Modal buttons
        function closeAppModal(result) {
            if (!appModalOverlay) return;
            appModalOverlay.classList.add('hidden');
            const r = __modalResolve;
            __modalResolve = null;
            if (typeof r === 'function') r(result);
        }
        appModalOkBtn?.addEventListener('click', () => closeAppModal(true));
        appModalCancelBtn?.addEventListener('click', () => closeAppModal(false));
        appModalCloseBtn?.addEventListener('click', () => closeAppModal(false));
        appModalOverlay?.addEventListener('click', (e) => {
            if (e.target === appModalOverlay) closeAppModal(false);
        });
        document.addEventListener('keydown', (e) => {
            if (appModalOverlay?.classList.contains('hidden')) return;
            if (e.key === 'Escape') closeAppModal(false);
        });

        // Open editor when clicking the drawing button (now: overlay icon)
        toggleDrawPanelBtn?.addEventListener('click', () => editorOpen());
        drawFab?.addEventListener('click', () => editorOpen());

        function clonePoints(pts) {
            return (pts || []).map(p => [p[0], p[1]]);
        }

        function dist2(a, b) {
            const dx = a[0] - b[0];
            const dy = a[1] - b[1];
            return dx * dx + dy * dy;
        }

        function norm(v) {
            const l = Math.hypot(v[0], v[1]) || 1;
            return [v[0] / l, v[1] / l];
        }

        function add(a, b) { return [a[0] + b[0], a[1] + b[1]]; }
        function sub(a, b) { return [a[0] - b[0], a[1] - b[1]]; }
        function mul(a, k) { return [a[0] * k, a[1] * k]; }

        function drawArrow(ctx, from, to, color = '#10B0F9', opts = {}) {
            const v = sub(to, from);
            const u = norm(v);
            const head = Number(opts.head ?? 22);
            const wing = Number(opts.wing ?? 13);
            const shaftWidth = Number(opts.shaftWidth ?? 2);
            const dashed = !!opts.dashed;
            const outline = opts.outline !== false; // default true
            const handle = opts.handle !== false;  // default true
            // shaft
            ctx.beginPath();
            ctx.moveTo(from[0], from[1]);
            ctx.lineTo(to[0], to[1]);
            ctx.strokeStyle = color;
            ctx.lineWidth = shaftWidth;
            ctx.setLineDash(dashed ? [6, 4] : []);
            ctx.stroke();
            ctx.setLineDash([]);

            // head
            const left = add(to, add(mul(u, -head), mul([-u[1], u[0]], wing)));
            const right = add(to, add(mul(u, -head), mul([u[1], -u[0]], wing)));
            ctx.beginPath();
            ctx.moveTo(to[0], to[1]);
            ctx.lineTo(left[0], left[1]);
            ctx.lineTo(right[0], right[1]);
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
            if (outline) {
                ctx.strokeStyle = 'rgba(255,255,255,0.9)';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // handle
            if (handle) {
                ctx.beginPath();
                ctx.arc(to[0], to[1], 10, 0, Math.PI * 2);
                ctx.fillStyle = '#ffffff';
                ctx.globalAlpha = 0.9;
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        function getLineDraftMidAndDefaultDir() {
            if (editorState.tool !== 'line') return null;
            if (editorState.points.length !== 2) return null;
            const p1 = editorState.points[0];
            const p2 = editorState.points[1];
            const mid = [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2];
            const v = sub(p2, p1);
            const u = norm(v);
            // default direction = perp to line
            const perp = [-u[1], u[0]];
            const end = add(mid, mul(perp, 60));
            return { mid, end };
        }

        function lineHandleHit(p, handleEnd) {
            // Hit area plus permissive pour attraper la poignée de flèche en édition
            return dist2(p, handleEnd) <= (26 * 26);
        }

        function getCanvasPointFromEvent(e) {
            const rect = drawCanvas.getBoundingClientRect();
            const scaleX = drawCanvas.width / rect.width;
            const scaleY = drawCanvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            return [x, y];
        }

        function nearestVertexIndex(pts, p, radiusPx = HANDLE_RADIUS) {
            const r2 = radiusPx * radiusPx;
            let bestIdx = -1;
            let bestD = Infinity;
            for (let i = 0; i < pts.length; i++) {
                const d = dist2(pts[i], p);
                if (d < bestD) {
                    bestD = d;
                    bestIdx = i;
                }
            }
            return bestD <= r2 ? bestIdx : -1;
        }

        function pointToSegmentDistanceSquared(p, a, b) {
            const vx = b[0] - a[0];
            const vy = b[1] - a[1];
            const wx = p[0] - a[0];
            const wy = p[1] - a[1];
            const c1 = vx * wx + vy * wy;
            if (c1 <= 0) return dist2(p, a);
            const c2 = vx * vx + vy * vy;
            if (c2 <= c1) return dist2(p, b);
            const t = c1 / c2;
            const proj = [a[0] + t * vx, a[1] + t * vy];
            return dist2(p, proj);
        }

        function insertPointOnNearestEdge(pts, p) {
            if (!pts || pts.length < 3) return false;
            let bestIdx = -1;
            let bestD = Infinity;
            for (let i = 0; i < pts.length; i++) {
                const a = pts[i];
                const b = pts[(i + 1) % pts.length];
                const d = pointToSegmentDistanceSquared(p, a, b);
                if (d < bestD) {
                    bestD = d;
                    bestIdx = i;
                }
            }
            // Seuil d’insertion (en px canvas)
            if (bestD > (18 * 18)) return false;
            pts.splice(bestIdx + 1, 0, [p[0], p[1]]);
            return true;
        }

        function setEditMode(on) {
            editMode = on;
            editDragging = null;
        }

        async function saveEditedPolygon() {
            if (!currentVideo || !selectedAsset || !selectedAsset.zone) return;
            if (!editPoints || !Array.isArray(editPoints)) return;

            const zoneName = selectedAsset.zone;
            const idx = selectedAsset.idx;
            const polygons = clonePointsArray((cachedZones[zoneName]?.polygons) || []);
            if (typeof idx !== 'number' || !polygons[idx]) return;

            polygons[idx] = clonePoints(editPoints);

            const res = await fetch(`/api/zones/${encodeURIComponent(currentVideo)}/${encodeURIComponent(zoneName)}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ polygons })
            });
            if (!res.ok) {
                uiAlert('Erreur sauvegarde (PUT zone).', 'Zones');
                return;
            }
            await loadZones();
            await drawExistingZones();
            setEditMode(false);
        }

        function clonePointsArray(polys) {
            return (polys || []).map(poly => clonePoints(poly));
        }
        const steps = {
            step1: document.getElementById('step1'),
            step2: document.getElementById('step2'),
            step3: document.getElementById('step3')
        };

        function setView(view) {
            currentView = view;
            const isHome = view === 'home';

            homeView.classList.toggle('hidden', !isHome);
            trackerView.classList.toggle('hidden', isHome);

            navSites.classList.toggle('active', isHome);
            navTracker.classList.toggle('active', !isHome);

            if (stepsEl) stepsEl.style.display = isHome ? 'none' : '';

            if (isHome) {
                pageTitleEl.textContent = 'Sites';
                pageSubtitleEl.textContent = 'Choisissez un site ou créez-en un pour démarrer la configuration';
                renderSitesSidebar();
            } else {
                const siteLabel = currentSite?.name ? ` — ${currentSite.name}` : '';
                pageTitleEl.textContent = `Zone Presence Tracker${siteLabel}`;
                pageSubtitleEl.textContent = 'Surveillance et analyse du temps de présence';
            }
        }

        function loadSites() {
            renderSitesHome();
            if (currentView === 'home') renderSitesSidebar();
        }

        function escapeHtml(text) {
            return String(text ?? '')
                .replaceAll('&', '&amp;')
                .replaceAll('<', '&lt;')
                .replaceAll('>', '&gt;')
                .replaceAll('"', '&quot;')
                .replaceAll("'", '&#39;');
        }

        function renderSitesHome() {
            if (!sitesGrid) return;
            if (!sitesCache || sitesCache.length === 0) {
                sitesGrid.innerHTML = '<div class="no-zones">Aucun site. Créez-en un pour commencer.</div>';
                return;
            }

            sitesGrid.innerHTML = sitesCache.map((s) => {
                const cams = s.cameras || [];
                const camLines = cams.map(c => `${c.id}: ${c.name} • ${c.video}`).slice(0, 3);
                const siteName = escapeHtml(s.name);
                const siteKey = encodeURIComponent(String(s.name ?? ''));
                const demoName = DEMO_SITES?.[0]?.name;
                const canDelete = !(demoName && s.name === demoName);
                return `
                    <div class="zone-card site-card" style="cursor:pointer;" data-site="${siteKey}">
                        <div class="zone-card-header">
                            <div class="zone-card-name">${siteName}</div>
                            <div style="display:flex; align-items:center; gap: var(--space-2);">
                                <div class="zone-card-status empty">${cams.length} caméra(s)</div>
                                ${canDelete ? `<button class="btn btn-ghost btn-icon" data-delete-site="${siteKey}" title="Supprimer" type="button">✕</button>` : ''}
                            </div>
                        </div>
                        <div style="margin-top: var(--space-2); color: var(--color-text-muted); font-size: var(--text-xs);">
                            ${camLines.map(l => `<div>${l}</div>`).join('')}
                        </div>
                        <div class="zone-card-time" style="font-size: var(--text-sm);">Configurer</div>
                    </div>
                `;
            }).join('');
        }

        function renderSitesSidebar() {
            if (!zoneListSidebar) return;
            if (!sitesCache || sitesCache.length === 0) {
                zoneListSidebar.innerHTML = '<div style="color: var(--sidebar-text-subtle); font-size: var(--text-sm);">Aucun site</div>';
                return;
            }
            zoneListSidebar.innerHTML = `
                <div class="draw-tree">
                    ${sitesCache.map((s) => `
                        <div class="tree-row site-row" data-site="${encodeURIComponent(String(s.name ?? ''))}">
                            <div class="left">
                                <span class="label">🏢 ${escapeHtml(s.name)}</span>
                            </div>
                            <span class="meta">${(s.cameras || []).length} cam</span>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function createSite(name) {
            const n = String(name || '').trim();
            if (!n) throw new Error('Nom de site requis');
            if ((sitesCache || []).some(s => s.name === n)) throw new Error('Site déjà existant');
            // nouveau site vide (0 caméra)
            sitesCache.push({ name: n, cameras: [] });
        }

        function cameraIdFromName(name) {
            const base = String(name || '')
                .trim()
                .toLowerCase()
                .replaceAll(/[^a-z0-9]+/g, '-')
                .replaceAll(/(^-|-$)/g, '');
            return base || 'cam';
        }

        function makeUniqueCameraId(cameras, desiredId) {
            const used = new Set((cameras || []).map(c => c.id));
            let id = desiredId;
            let n = 2;
            while (used.has(id)) {
                id = `${desiredId}-${n}`;
                n += 1;
            }
            return id;
        }

        function saveCurrentSiteCameras(cameras) {
            if (!currentSite?.name) throw new Error('Aucun site sélectionné');
            const idx = (sitesCache || []).findIndex(s => s.name === currentSite.name);
            if (idx < 0) throw new Error('Site introuvable');
            sitesCache[idx].cameras = cameras;
            currentSite = sitesCache[idx];
        }

        function deleteSiteByName(name) {
            const n = String(name || '').trim();
            const demoName = DEMO_SITES?.[0]?.name;
            if (n && demoName && n === demoName) throw new Error('Impossible de supprimer le site démo');
            const idx = (sitesCache || []).findIndex(s => s.name === n);
            if (idx >= 0) sitesCache.splice(idx, 1);
            if (currentSite?.name === n) {
                currentSite = null;
                currentVideo = null;
                currentCameraId = null;
                selectedAsset = null;
                setView('home');
            }
        }

        async function selectSiteByName(name) {
            const found = (sitesCache || []).find(s => s.name === name);
            currentSite = found || { name, cameras: [] };

            // Reset selection when switching sites
            currentVideo = null;
            currentCameraId = null;
            selectedAsset = null;

            setView('tracker');
            await loadVideos();

            // Auto select first camera if possible
            const cams = getActiveCameras();
            if (cams.length > 0) {
                selectCamera(cams[0].id);
            }
            await loadZones();
            updateSteps();
        }

        // Initialize
        init();

        async function init() {
            // Important: récupérer d'abord les streams, puis construire l'UI (évite les “resets”)
            await updateActiveStreams();
            loadSites();

            // Nav
            navSites?.addEventListener('click', () => setView('home'));
            navTracker?.addEventListener('click', async () => {
                if (!currentSite) {
                    setView('home');
                    return;
                }
                setView('tracker');
                await loadVideos();
                await loadZones();
                updateSteps();
            });

            // Create site
            async function handleCreateSite() {
                const name = (newSiteNameInput?.value || '').trim();
                if (!name) return;
                try {
                    createSite(name);
                    newSiteNameInput.value = '';
                    loadSites();
                    await selectSiteByName(name);
                } catch (e) {
                    uiAlert(`Erreur création site: ${e?.message || e}`, 'Sites');
                }
            }
            createSiteBtn?.addEventListener('click', handleCreateSite);
            newSiteNameInput?.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') handleCreateSite();
            });

            // Add camera (site)
            function openAddCameraForm() {
                if (!addCameraForm) return;
                addCameraForm.classList.remove('hidden');
                // populate videos
                if (newCamVideo) {
                    newCamVideo.innerHTML = '';
                    (availableVideosList || []).forEach((v) => {
                        newCamVideo.innerHTML += `<option value="${escapeHtml(v)}">${escapeHtml(v)}</option>`;
                    });
                }
                newCamName?.focus();
            }
            function closeAddCameraForm() {
                addCameraForm?.classList.add('hidden');
                if (newCamName) newCamName.value = '';
                if (newCamHint) newCamHint.value = '';
            }
            addCameraBtn?.addEventListener('click', () => {
                if (currentView !== 'tracker') return;
                openAddCameraForm();
            });
            cancelCamBtn?.addEventListener('click', closeAddCameraForm);
            saveCamBtn?.addEventListener('click', async () => {
                const name = (newCamName?.value || '').trim();
                const video = (newCamVideo?.value || '').trim();
                const hint = (newCamHint?.value || '').trim();
                if (!name || !video) {
                    uiAlert('Nom et vidéo requis.', 'Caméras');
                    return;
                }
                try {
                    const cams = Array.isArray(currentSite?.cameras) ? [...currentSite.cameras] : [];
                    const desired = cameraIdFromName(name);
                    const id = makeUniqueCameraId(cams, desired);
                    cams.push({ id, name, hint, video });
                    saveCurrentSiteCameras(cams);
                    loadSites();
                    closeAddCameraForm();
                    await loadVideos();
                    if (!currentVideo) selectCamera(id);
                    await loadZones();
                } catch (e) {
                    uiAlert(`Erreur ajout caméra: ${e?.message || e}`, 'Caméras');
                }
            });

            // Click delegation for site cards/rows
            sitesGrid?.addEventListener('click', async (e) => {
                const del = e.target?.closest?.('[data-delete-site]');
                if (del) {
                    const key = del.getAttribute('data-delete-site') || '';
                    const name = decodeURIComponent(key);
                    const ok = await uiConfirm(`Supprimer le site "${name}" ?`, 'Suppression');
                    if (ok) {
                        try { deleteSiteByName(name); loadSites(); } catch (err) { uiAlert(err?.message || String(err), 'Suppression'); }
                    }
                    return;
                }
                const el = e.target?.closest?.('[data-site]');
                if (!el) return;
                const key = el.getAttribute('data-site') || '';
                const name = decodeURIComponent(key);
                selectSiteByName(name);
            });
            zoneListSidebar?.addEventListener('click', (e) => {
                const el = e.target?.closest?.('[data-site]');
                if (!el) return;
                const key = el.getAttribute('data-site') || '';
                const name = decodeURIComponent(key);
                selectSiteByName(name);
            });

            // DEMO: always start on home; refresh resets sites to DEMO_SITES
            setView('home');

            function startLoadZonesLoop() {
                if (loadZonesLoopTimer) clearTimeout(loadZonesLoopTimer);
                const tick = async () => {
                    const isDetecting = !!(currentVideo && activeVideoStreams.has(currentVideo));
                    const nextMs = isDetecting ? PRESENCE_POLL_ACTIVE_MS : PRESENCE_POLL_IDLE_MS;
                    try { await loadZones(); } catch {}
                    loadZonesLoopTimer = setTimeout(tick, nextMs);
                };
                tick();
            }
            startLoadZonesLoop();
            setInterval(updateActiveStreams, 2000);
        }

        const DEFAULT_CAMERA_DEFS = [
            {
                id: 'entr1',
                name: 'Entrepôt / Logistique',
                hint: 'Déchargement & présence',
                video: 'entr1.mp4'
            },
            {
                id: 'convoyeur',
                name: 'Convoyeur / Ligne',
                hint: 'Tapis roulant & contrôle',
                video: 'video_01.mp4'
            }
        ];

        function getActiveCameras() {
            // En mode multi-site: un site peut être vide (0 caméra)
            if (currentSite && Array.isArray(currentSite.cameras)) return currentSite.cameras;
            return [];
        }

        function getCameraByVideo(videoName) {
            return getActiveCameras().find(c => c.video === videoName) || null;
        }

        function getCameraById(id) {
            return getActiveCameras().find(c => c.id === id) || null;
        }

        async function loadVideos() {
            const res = await fetch('/api/videos');
            const data = await res.json();
            const available = new Set(data.videos || []);
            const cams = getActiveCameras();
            availableVideosList = data.videos || [];

            // Garder la liste de vidéos pour l'interne (upload / fallback)
            const selected = videoSelect.value || currentVideo || '';
            videoSelect.innerHTML = '<option value="">-- Choisir une vidéo --</option>';
            (data.videos || []).forEach((v) => {
                videoSelect.innerHTML += `<option value="${v}">${v}</option>`;
            });
            if (selected && available.has(selected)) videoSelect.value = selected;

            // UI: 2 caméras fixes (simple & fiable)
            cameraGrid.innerHTML = '';
            if (!cams || cams.length === 0) {
                cameraGrid.innerHTML = `
                    <div class="no-zones" style="grid-column: 1 / -1; text-align:left;">
                        Aucune caméra sur ce site. Cliquez sur <b>+</b> pour en ajouter une.
                    </div>
                `;
                return;
            }
            cams.forEach((cam) => {
                const videoExists = available.has(cam.video);
                const isActive = activeVideoStreams.has(cam.video);
                const isCurrent = cam.video === currentVideo;
                const statusText = videoExists ? (isActive ? 'En ligne' : 'Prête') : 'Manquante';

                cameraGrid.innerHTML += `
                    <div class="camera-item ${isCurrent ? 'active' : ''}" data-camera="${cam.id}" onclick="selectCamera('${cam.id}')">
                        <div class="camera-item-name">${cam.name}</div>
                        <div class="camera-item-status ${videoExists ? (isActive ? 'online' : 'offline') : 'offline'}">
                            <span class="camera-status-dot" style="width:6px;height:6px;border-radius:50%;background:currentColor;"></span>
                            <span class="camera-status-text">${statusText}</span>
                        </div>
                        <div style="margin-top: var(--space-2); font-size: var(--text-xs); color: var(--color-text-muted);">
                            ${(cam.hint || '')} • <span style="font-family: 'Courier New', monospace;">${cam.video}</span>
                        </div>
                    </div>
                `;
            });
        }

        function selectVideo(videoName) {
            videoSelect.value = videoName;
            videoSelect.dispatchEvent(new Event('change'));
        }

        function selectCamera(cameraId) {
            const cam = getCameraById(cameraId);
            if (!cam) return;
            currentCameraId = cameraId;
            selectVideo(cam.video);
        }

        async function updateActiveStreams() {
            try {
                const prev = new Set(activeVideoStreams || []);
                const res = await fetch('/api/streams');
                const data = await res.json();

                activeVideoStreams = new Set(data.streams.map(s => s.video));

                // Diff start/stop pour garder les compteurs cohérents même si le stream a été lancé ailleurs
                for (const v of activeVideoStreams) {
                    if (!prev.has(v)) {
                        markVideoRunStart(v);
                        ensureZoneLive(v).lastTs = Date.now();
                    }
                }
                for (const v of prev) {
                    if (!activeVideoStreams.has(v)) {
                        markVideoRunStop(v);
                        if (zoneLiveTimersByVideo?.[v]) zoneLiveTimersByVideo[v].lastTs = 0;
                    }
                }

                if (data.streams.length === 0) {
                    activeStreamsDiv.innerHTML = '';
                    stopAllBtn.classList.add('hidden');
                } else {
                    activeStreamsDiv.innerHTML = data.streams.map(s =>
                        `<span class="stream-badge ${s.video === currentVideo ? 'current' : ''}">
                            <span class="dot"></span>
                            ${s.video}
                        </span>`
                    ).join('');
                    stopAllBtn.classList.remove('hidden');
                }

                if (currentVideo) {
                    isCurrentVideoStreaming = activeVideoStreams.has(currentVideo);
                    if (isCurrentVideoStreaming) {
                        startDetectionBtn.classList.add('hidden');
                        stopDetectionBtn.classList.remove('hidden');
                    } else {
                        startDetectionBtn.classList.remove('hidden');
                        stopDetectionBtn.classList.add('hidden');
                    }
                }

                // Met à jour les cartes caméras sans reconstruire le DOM (évite le jitter)
                document.querySelectorAll('.camera-item[data-camera]').forEach((el) => {
                    const camId = el.getAttribute('data-camera');
                    const cam = getCameraById(camId);
                    if (!cam) return;

                    const active = activeVideoStreams.has(cam.video);
                    const isCurrent = cam.video === currentVideo;
                    el.classList.toggle('active', isCurrent);

                    const statusEl = el.querySelector('.camera-item-status');
                    if (!statusEl) return;

                    statusEl.classList.toggle('online', active);
                    statusEl.classList.toggle('offline', !active);
                    const textEl = statusEl.querySelector('.camera-status-text');
                    if (textEl) textEl.textContent = active ? 'En ligne' : 'Prête';
                });

                // steps KPI (site) + cache zones (site)
                if (currentView === 'tracker' && currentSite) {
                    refreshZonesCacheForSite(false).then(updateHeaderStepsKpis).catch(() => updateHeaderStepsKpis());
                } else {
                    updateHeaderStepsKpis();
                }
            } catch (e) {
                console.error('Error fetching streams:', e);
            }
        }

        async function loadZones() {
            if (loadZonesInFlight) return;
            loadZonesInFlight = true;
            try {
            if (currentView !== 'tracker') return;
            if (!currentVideo) {
                const cams = getActiveCameras();
                zonesGrid.innerHTML = '<div class="no-zones">Sélectionnez une vidéo</div>';
                zoneListSidebar.innerHTML = '<div style="color: var(--sidebar-text-subtle); font-size: var(--text-sm);">Sélectionnez une vidéo</div>';
                recapCameras.textContent = `${cams.length}`;
                recapCamerasSub.textContent = 'Caméras configurées';
                recapZones.textContent = '—';
                recapZonesSub.textContent = 'Sélectionnez une caméra';
                recapDrawings.textContent = '—';
                recapDrawingsSub.textContent = '—';
                recapActive.textContent = '—';
                recapActiveSub.textContent = '—';
                updateHeaderStepsKpis();
                return;
            }
            const isDetecting = activeVideoStreams.has(currentVideo);
            // Note: le dénominateur (pour % occupation/absence) ne doit avancer QUE quand la détection tourne.
            // (On garde le cumul par vidéo tant que la page reste ouverte.)
            // refresh cache zones pour le site (toutes caméras)
            await refreshZonesCacheForSite(false);

            // Définitions zones: ne pas re-fetch à chaque tick (sinon on sature quand on augmente la cadence)
            let zonesWithPolygons = zonesCacheByVideo[currentVideo] || {};
            const nowDefs = Date.now();
            const needDefs =
                !zonesDefsFetchedByVideo[currentVideo] ||
                (nowDefs - Number(zonesDefsFetchTsByVideo[currentVideo] || 0)) > ZONES_DEF_TTL_MS;
            if (needDefs) {
                const zonesRes = await fetch(`/api/zones/${encodeURIComponent(currentVideo)}`);
                const zonesData = await zonesRes.json();
                zonesWithPolygons = zonesData.zones || {};
                zonesCacheByVideo[currentVideo] = zonesWithPolygons;
                zonesDefsFetchTsByVideo[currentVideo] = nowDefs;
                zonesDefsFetchedByVideo[currentVideo] = true;
            }

            const isLineZone = (zoneName) => {
                const polys = zonesWithPolygons?.[zoneName]?.polygons || [];
                for (let i = 0; i < polys.length; i++) {
                    if (getDrawType(currentVideo, zoneName, i) === 'line') return true;
                }
                return false;
            };

            // Présence:
            // - si détection active: on fetch et on met à jour le snapshot
            // - sinon: on gèle sur le dernier snapshot (ou 0 si jamais lancé)
            let zones = {};
            if (isDetecting) {
                try {
                    const presenceRes = await fetch(`/api/presence/${encodeURIComponent(currentVideo)}`);
                    const presenceData = await presenceRes.json();
                    zones = presenceData.zones || {};
                    lastPresenceByVideo[currentVideo] = zones;
                    presenceOkTsByVideo[currentVideo] = Date.now();
                    // Met à jour les compteurs locaux (occupation/absence) selon is_occupied
                    updateZoneLiveTimers(currentVideo, zones);
                    // Line zones: compte les passages + série
                    updateLinePass(currentVideo, zones, isLineZone);
                } catch (e) {
                    // Anti "état figé": si /presence échoue, ne pas conserver un ancien "Occupé"
                    zones = {};
                    presenceOkTsByVideo[currentVideo] = 0;
                }
            } else {
                zones = (videoHasRunByVideo[currentVideo] ? (lastPresenceByVideo[currentVideo] || {}) : {});
            }

            // Recap (camera + zones + drawings + active presence)
            const online = activeVideoStreams.size;
            recapCameras.textContent = `${online}/${getActiveCameras().length}`;
            recapCamerasSub.textContent = 'En ligne / configurées';

            const zoneCount = Object.keys(zonesWithPolygons).length;
            recapZones.textContent = `${zoneCount}`;
            recapZonesSub.textContent = 'Zones sur cette caméra';

            let drawingsCount = 0;
            for (const z of Object.values(zonesWithPolygons)) drawingsCount += (z.polygons || []).length;
            recapDrawings.textContent = `${drawingsCount}`;
            recapDrawingsSub.textContent = 'Dessins sur cette caméra';

            const lastOk = Number(presenceOkTsByVideo[currentVideo] || 0);
            const stale = isDetecting ? (!lastOk || ((Date.now() - lastOk) > PRESENCE_STALE_MS)) : false;
            const activeCount = (isDetecting && !stale) ? Object.values(zones).filter(z => z.is_occupied).length : 0;
            recapActive.textContent = `${activeCount}`;
            recapActiveSub.textContent = isDetecting ? (stale ? 'Sync…' : 'Zones occupées') : (videoHasRunByVideo[currentVideo] ? 'Détection en pause' : 'Lancez la détection');

            if (Object.keys(zonesWithPolygons).length === 0) {
                zonesGrid.innerHTML = '<div class="no-zones">Aucune zone définie pour cette vidéo</div>';
                zoneListSidebar.innerHTML = '<div style="color: var(--sidebar-text-subtle); font-size: var(--text-sm);">Aucune zone</div>';
                updateDrawPanelZones(zonesWithPolygons);
                return;
            }

            zonesGrid.innerHTML = '';
            zoneListSidebar.innerHTML = '';
            updateDrawPanelZones(zonesWithPolygons);

            for (const name of Object.keys(zonesWithPolygons).sort()) {
                const info = zones[name] || { formatted_time: '00:00:00', is_occupied: false, total_time: 0 };
                const lastOk = Number(presenceOkTsByVideo[currentVideo] || 0);
                const stale = isDetecting ? (!lastOk || ((Date.now() - lastOk) > PRESENCE_STALE_MS)) : false;
                const uiOcc = isDetecting && !stale && !!info.is_occupied;
                const statusClass = isDetecting ? (stale ? 'empty' : (uiOcc ? 'occupied' : 'empty')) : 'empty';
                const statusLabel = isDetecting ? (stale ? 'Sync…' : (uiOcc ? 'Occupé' : 'Vide')) : (videoHasRunByVideo[currentVideo] ? 'Pause' : 'Prêt');
                const polys = (zonesWithPolygons[name]?.polygons || []);
                const drawings = polys.length;

                const previews = polys.slice(0, 2);
                const previewBoxes = previews.map((poly, idx) => {
                    const svg = buildPolyPreviewSvg(poly);
                    const isSel = selectedAsset && selectedAsset.zone === name && typeof selectedAsset.idx === 'number' && selectedAsset.idx === idx;
                    const zKey = encodeURIComponent(String(name));
                    return `
                        <div class="zone-preview-box ${isSel ? 'active' : ''}" data-zone="${zKey}" data-idx="${idx}" title="Sélectionner la forme #${idx + 1}">
                            ${svg}
                        </div>
                    `;
                }).join('');

                const isSelected = selectedAsset && selectedAsset.zone === name;

                // Compteurs locaux (fiables): occupation + absence
                const live = zoneLiveTimersByVideo?.[currentVideo]?.zones?.[name] || { occ: 0, abs: 0 };
                const occSec = (isDetecting || videoHasRunByVideo[currentVideo]) ? Number(live.occ || 0) : 0;
                const absSec = (isDetecting || videoHasRunByVideo[currentVideo]) ? Number(live.abs || 0) : 0;
                const denom = occSec + absSec;
                const occPct = denom > 0 ? Math.min(100, Math.max(0, (occSec / denom) * 100)) : 0;
                const absPct = denom > 0 ? Math.max(0, 100 - occPct) : 0;
                const secFmt = (s) => `${Math.max(0, Math.floor(Number(s) || 0))} s`;

                const isLine = isLineZone(name);
                const linePass = linePassByVideo?.[currentVideo]?.[name] || { count: 0, series: [] };
                const uptime = denom; // temps total où la détection tournait (par zone)
                const passageTime = occSec; // temps "actif" sur la ligne (proxy passage)

                zonesGrid.innerHTML += `
                    <div class="zone-card ${isSelected ? 'selected' : ''}" data-zone="${encodeURIComponent(String(name))}">
                        <div class="zone-card-header">
                            <div>
                                <div class="zone-name-pill">${name}</div>
                                <div class="zone-forms-count">${drawings} forme(s)</div>
                            </div>
                            <div class="zone-card-status ${statusClass}">${statusLabel}</div>
                        </div>
                        <div class="zone-previews">
                            ${previewBoxes}
                        </div>
                        ${isLine ? `
                            <div class="line-metrics">
                                <div class="line-metric"><span>Passages</span><span>${Number(linePass.count || 0)}</span></div>
                                <div class="line-metric"><span>Uptime</span><span>${formatHMS(uptime)}</span></div>
                                <div class="line-metric" style="grid-column:1 / -1;"><span>Temps passage</span><span>${secFmt(passageTime)}</span></div>
                            </div>
                            <div class="line-spark">${buildSparklineSvg(linePass.series)}</div>
                        ` : `
                            <div class="occ-bars">
                                <div>
                                    <div class="occ-head">
                                        <span><strong>Occupation</strong> • <span class="pct">${occPct.toFixed(0)}%</span></span>
                                        <span class="secs">${secFmt(occSec)}</span>
                                    </div>
                                    <div class="occ-track"><div class="occ-fill" style="width:${occPct.toFixed(2)}%"></div></div>
                                </div>
                                <div>
                                    <div class="occ-head">
                                        <span><strong>Absence</strong> • <span class="pct">${absPct.toFixed(0)}%</span></span>
                                        <span class="secs">${secFmt(absSec)}</span>
                                    </div>
                                    <div class="occ-track"><div class="occ-fill red" style="width:${absPct.toFixed(2)}%"></div></div>
                                </div>
                            </div>
                        `}
                        <div class="zone-card-actions">
                            <button class="btn btn-ghost btn-icon" onclick="resetZoneTimer('${name}')" title="Reset">
                                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                `;

                // Sidebar explorer: Source vidéo > Zones > Dessins
                const polyCount = (zonesWithPolygons[name]?.polygons || []).length;
                zonePolygonCounts[name] = polyCount;
            }

            // Render explorer tree
            renderAssetTree(zones, zonesWithPolygons);
            updateHeaderStepsKpis();
            } finally {
                loadZonesInFlight = false;
            }
        }

        function updateDrawPanelZones(zonesWithPolygons) {
            const prev = drawZoneSelect.value;
            drawZoneSelect.innerHTML = '<option value="">— Choisir —</option><option value="__new__">+ Nouvelle zone…</option>';
            Object.keys(zonesWithPolygons || {}).sort().forEach((z) => {
                drawZoneSelect.innerHTML += `<option value="${z}">${z}</option>`;
            });
            if (prev && [...drawZoneSelect.options].some(o => o.value === prev)) {
                drawZoneSelect.value = prev;
            }
            drawZoneNameGroup.classList.toggle('hidden', drawZoneSelect.value !== '__new__');
        }

        function getDrawType(video, zone, idx) {
            try {
                return localStorage.getItem(`drawmeta:${video}:${zone}:${idx}`) || 'include';
            } catch {
                return 'include';
            }
        }

        function setDrawType(video, zone, idx, type) {
            try {
                localStorage.setItem(`drawmeta:${video}:${zone}:${idx}`, type);
            } catch {}
        }

        function setLineMeta(video, zone, idx, meta) {
            try {
                localStorage.setItem(`linemeta:${video}:${zone}:${idx}`, JSON.stringify(meta || {}));
            } catch {}
        }

        function getLineMeta(video, zone, idx) {
            try {
                const raw = localStorage.getItem(`linemeta:${video}:${zone}:${idx}`);
                if (!raw) return null;
                return JSON.parse(raw);
            } catch {
                return null;
            }
        }

        function computeLineArrowFromMeta(meta, polyFallback) {
            // Retourne { mid:[x,y], end:[x,y] } en coords canvas
            let mid = null;
            let dir = null;
            if (meta?.p1 && meta?.p2 && Array.isArray(meta.p1) && Array.isArray(meta.p2)) {
                mid = [(meta.p1[0] + meta.p2[0]) / 2, (meta.p1[1] + meta.p2[1]) / 2];
                if (meta?.dir && Array.isArray(meta.dir)) dir = meta.dir;
                else {
                    const u = norm(sub(meta.p2, meta.p1));
                    dir = [-u[1], u[0]];
                }
            }
            if (!mid && polyFallback?.length) {
                // fallback grossier: centre du polygone + direction selon la plus longue arête
                let cx = 0, cy = 0;
                for (const p of polyFallback) { cx += p[0]; cy += p[1]; }
                cx /= polyFallback.length; cy /= polyFallback.length;
                mid = [cx, cy];
                let best = { d: 0, v: [1, 0] };
                for (let i = 0; i < polyFallback.length; i++) {
                    const a = polyFallback[i];
                    const b = polyFallback[(i + 1) % polyFallback.length];
                    const v = sub(b, a);
                    const d = v[0] * v[0] + v[1] * v[1];
                    if (d > best.d) best = { d, v };
                }
                const u = norm(best.v);
                dir = [-u[1], u[0]];
            }
            if (!mid) return null;
            const udir = norm(dir || [0, -1]);
            const end = add(mid, mul(udir, 60));
            return { mid, end, dir: udir };
        }

        function buildPolyPreviewSvg(poly) {
            if (!poly || poly.length < 3) return '';
            // Normalise points to a small viewBox with padding
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            for (const p of poly) {
                minX = Math.min(minX, p[0]); minY = Math.min(minY, p[1]);
                maxX = Math.max(maxX, p[0]); maxY = Math.max(maxY, p[1]);
            }
            const w = Math.max(1, maxX - minX);
            const h = Math.max(1, maxY - minY);
            const pad = 6;
            const vw = 100, vh = 64;
            const sx = (vw - pad * 2) / w;
            const sy = (vh - pad * 2) / h;
            const s = Math.min(sx, sy);
            const pts = poly.map(p => {
                const x = (p[0] - minX) * s + pad;
                const y = (p[1] - minY) * s + pad;
                return `${x.toFixed(1)},${y.toFixed(1)}`;
            }).join(' ');
            return `
                <svg viewBox="0 0 ${vw} ${vh}" width="100%" height="100%" preserveAspectRatio="xMidYMid meet">
                    <polygon points="${pts}" fill="rgba(34,197,94,0.18)" stroke="#22c55e" stroke-width="3" />
                </svg>
            `;
        }

        function colorsForType(type, isActive = false) {
            // palette: include=vert, line=bleu, exclude=orange/rouge
            const base = {
                include: { stroke: '#22c55e', fill: 'rgba(34,197,94,0.16)' },
                line: { stroke: '#10B0F9', fill: 'rgba(16,176,249,0.12)' },
                exclude: { stroke: '#F08321', fill: 'rgba(240,131,33,0.16)' }
            }[type] || { stroke: '#22c55e', fill: 'rgba(34,197,94,0.16)' };
            if (!isActive) return base;
            return { stroke: '#10B0F9', fill: 'rgba(16,176,249,0.18)' };
        }

        function renderAssetTree(presenceZones, zonesWithPolygons) {
            const root = `
                <div class="draw-tree">
                    <div class="tree-row" onclick="selectVideo('${currentVideo}')">
                        <div class="left">
                            <span class="label">📹 ${(getCameraByVideo(currentVideo)?.name || currentVideo)}</span>
                        </div>
                        <span class="meta">${getCameraByVideo(currentVideo)?.id || 'Source'}</span>
                    </div>
                    <div class="tree-children">
                        ${Object.keys(zonesWithPolygons || {}).sort().map((zoneName) => {
                            const info = presenceZones[zoneName] || { formatted_time: '00:00:00', is_occupied: false };
                            const drawings = zonesWithPolygons[zoneName]?.polygons || [];
                            const dotClass = info.is_occupied ? 'occupied' : '';
                            const live = zoneLiveTimersByVideo?.[currentVideo]?.zones?.[zoneName] || { occ: 0, abs: 0 };
                            const isLine = (() => {
                                const polys = zonesWithPolygons?.[zoneName]?.polygons || [];
                                for (let i = 0; i < polys.length; i++) {
                                    if (getDrawType(currentVideo, zoneName, i) === 'line') return true;
                                }
                                return false;
                            })();
                            const uptime = Number(live.occ || 0) + Number(live.abs || 0);
                            const metaTime = (videoHasRunByVideo[currentVideo] || activeVideoStreams.has(currentVideo))
                                ? formatHMS(isLine ? uptime : (live.occ || 0))
                                : '00:00:00';
                            return `
                                <div class="tree-row" onclick="selectZone('${zoneName}')">
                                    <div class="left">
                                        <span class="zone-dot ${dotClass}"></span>
                                        <span class="label">${zoneName}</span>
                                    </div>
                                    <span class="meta">${metaTime}</span>
                                </div>
                                <div class="tree-children">
                                    ${drawings.map((_, idx) => `
                                        <div class="tree-row tree-leaf" onclick="selectDrawing('${zoneName}', ${idx})">
                                            <div class="left">
                                                <span class="label">Dessin ${idx + 1}</span>
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            `;
            zoneListSidebar.innerHTML = root;
        }

        // Globaux cliquables depuis le HTML (style explorateur)
        window.selectZone = (zoneName) => {
            drawZoneSelect.value = zoneName;
            drawZoneNameGroup.classList.add('hidden');
            selectedAsset = { zone: zoneName };
            drawExistingZones();
            syncPresenceSelectionUI();
        };

        window.selectDrawing = (zoneName, idx) => {
            selectedAsset = { zone: zoneName, idx };
            drawExistingZones();
            syncPresenceSelectionUI();
        };

        function syncPresenceSelectionUI() {
            // Applique la surbrillance immédiatement (sans attendre le prochain loadZones à 1s)
            try {
                const zSel = selectedAsset?.zone || null;
                const idxSel = (selectedAsset && typeof selectedAsset.idx === 'number') ? selectedAsset.idx : null;
                document.querySelectorAll('.zone-card[data-zone]').forEach((el) => {
                    const z = decodeURIComponent(el.getAttribute('data-zone') || '');
                    el.classList.toggle('selected', !!zSel && z === zSel);
                });
                document.querySelectorAll('.zone-preview-box[data-zone][data-idx]').forEach((el) => {
                    const z = decodeURIComponent(el.getAttribute('data-zone') || '');
                    const idx = Number(el.getAttribute('data-idx'));
                    el.classList.toggle('active', !!zSel && z === zSel && idxSel !== null && idx === idxSel);
                });
            } catch {}
        }

        // Click sur les cartes de la section "Présences" => surbrillance / sélection (reuse des mêmes fonctions que la sidebar)
        zonesGrid?.addEventListener('click', (e) => {
            const t = e.target;
            if (!(t instanceof Element)) return;
            // Ne pas déclencher si clic sur un bouton (reset, etc.)
            if (t.closest('button')) return;

            const preview = t.closest('.zone-preview-box');
            if (preview) {
                const z = decodeURIComponent(preview.getAttribute('data-zone') || '');
                const idx = Number(preview.getAttribute('data-idx'));
                if (z && Number.isFinite(idx)) window.selectDrawing(z, idx);
                return;
            }

            const card = t.closest('.zone-card[data-zone]');
            if (card) {
                const z = decodeURIComponent(card.getAttribute('data-zone') || '');
                if (z) window.selectZone(z);
            }
        });

        function updateSteps() {
            if (currentView !== 'tracker') {
                Object.values(steps).forEach(s => s.classList.remove('active', 'done'));
                return;
            }
            Object.values(steps).forEach(s => s.classList.remove('active', 'done'));

            if (!currentVideo) {
                steps.step1.classList.add('active');
            } else if (isDrawing) {
                steps.step1.classList.add('done');
                steps.step2.classList.add('active');
            } else if (isCurrentVideoStreaming) {
                steps.step1.classList.add('done');
                steps.step2.classList.add('done');
                steps.step3.classList.add('active');
            } else {
                steps.step1.classList.add('done');
                steps.step2.classList.add('active');
            }
        }

        function updateStatus(status) {
            statusBadge.className = 'status-indicator ' + status;
            if (status === 'streaming') {
                statusText.textContent = 'Détection en cours';
            } else if (status === 'drawing') {
                statusText.textContent = 'Mode dessin';
            } else {
                statusText.textContent = 'Prêt';
            }
        }

        function syncCanvasSize() {
            const img = videoFrame.classList.contains('hidden') ? videoStream : videoFrame;
            if (!img.naturalWidth) return;

            const displayWidth = img.clientWidth;
            const displayHeight = img.clientHeight;

            drawCanvas.style.width = displayWidth + 'px';
            drawCanvas.style.height = displayHeight + 'px';
        }

        // Video selection
        videoSelect.addEventListener('change', async () => {
            if (!videoSelect.value) return;

            // Stabilisation: changer de vidéo annule tout mode dessin en cours
            if (isDrawing) {
                exitDrawingMode();
            }
            selectedAsset = null;
            drawPanel.classList.add('hidden');

            currentVideo = videoSelect.value;
            const cam = getCameraByVideo(currentVideo);
            currentCameraId = cam ? cam.id : null;
            currentVideoTitle.textContent = cam ? cam.name : currentVideo;

            const infoRes = await fetch(`/api/videos/${encodeURIComponent(currentVideo)}/info`);
            const info = await infoRes.json();
            videoWidth = info.width;
            videoHeight = info.height;

            drawCanvas.width = videoWidth;
            drawCanvas.height = videoHeight;

            isCurrentVideoStreaming = activeVideoStreams.has(currentVideo);

            if (isCurrentVideoStreaming) {
                videoFrame.classList.add('hidden');
                videoStream.classList.remove('hidden');
                videoStream.src = `/api/stream/${encodeURIComponent(currentVideo)}`;
                drawCanvas.classList.add('hidden');
                updateStatus('streaming');
            } else {
                videoFrame.src = `/api/videos/${encodeURIComponent(currentVideo)}/frame?t=${Date.now()}`;
                videoFrame.classList.remove('hidden');
                videoStream.classList.add('hidden');
                videoStream.src = '';
                drawCanvas.classList.remove('hidden');
                updateStatus('ready');
            }

            placeholder.classList.add('hidden');
            startDetectionBtn.disabled = false;

            const img = isCurrentVideoStreaming ? videoStream : videoFrame;
            img.onload = () => {
                syncCanvasSize();
                if (!isCurrentVideoStreaming) {
                    drawExistingZones();
                }
            };

            await updateActiveStreams();
            await loadZones();
            updateSteps();
        });

        // Video upload
        videoUpload.addEventListener('change', async () => {
            if (!videoUpload.files.length) return;

            const formData = new FormData();
            formData.append('file', videoUpload.files[0]);

            await fetch('/api/videos/upload', {
                method: 'POST',
                body: formData
            });

            await loadVideos();
            videoSelect.value = videoUpload.files[0].name;
            videoSelect.dispatchEvent(new Event('change'));
            videoUpload.value = '';
        });

        function updateFinishButtonState() {
            const ok = (drawMode === 'poly' && drawPoints.length >= 3) || (drawMode === 'line' && drawPoints.length >= 2);
            finishBtn.disabled = !ok;
        }

        function beginDrawing(mode, name) {
            drawMode = mode;
            activeDrawZoneName = name;
            isDrawing = true;
            drawPoints = [];

            drawHud.classList.remove('hidden');
            drawHudTitle.textContent = `Mode dessin — ${name}`;
            drawInstructions.innerHTML = `
                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                </svg>
                ${mode === 'line'
                    ? 'Cliquez pour placer 2 points (ligne).'
                    : 'Cliquez pour placer les points (min 3) puis enregistrer.'}
            `;

            // Garantit que le canvas est visible pour capturer les clics
            drawCanvas.classList.remove('hidden');
            drawCanvas.classList.add('drawing');
            updateFinishButtonState();
            updateSteps();
            updateStatus('drawing');
        }

        function exitDrawingMode() {
            isDrawing = false;
            drawPoints = [];
            activeDrawZoneName = '';
            drawMode = 'poly';

            drawHud.classList.add('hidden');
            finishBtn.disabled = true;
            drawCanvas.classList.remove('drawing');
            updateSteps();
            updateStatus('ready');
        }

        // Panneau dessin (remplacé par l'éditeur “paint-like”)
        // (le toggle du panneau legacy est désactivé)

        drawZoneSelect.addEventListener('change', () => {
            const v = drawZoneSelect.value;
            drawZoneNameGroup.classList.toggle('hidden', v !== '__new__');
            if (v === '__new__') drawZoneName.focus();
        });

        toolPolyBtn.addEventListener('click', () => setTool('poly'));
        toolLineBtn.addEventListener('click', () => setTool('line'));

        editSelectedBtn.addEventListener('click', () => {
            if (!selectedAsset || !selectedAsset.zone || typeof selectedAsset.idx !== 'number') {
                uiAlert('Sélectionnez un dessin dans la sidebar (Source > Zone > Dessin).', 'Edition');
                return;
            }
            if (isCurrentVideoStreaming) {
                uiAlert('Mettez la détection en pause avant d’éditer.', 'Edition');
                return;
            }
            const poly = cachedZones?.[selectedAsset.zone]?.polygons?.[selectedAsset.idx];
            if (!poly) {
                uiAlert('Dessin introuvable.', 'Edition');
                return;
            }
            editPoints = clonePoints(poly);
            setEditMode(true);
            drawCanvas.classList.remove('hidden');
            drawCanvas.classList.add('drawing');
            redrawCanvas();
        });

        addPointBtn.addEventListener('click', () => {
            if (!editMode || !editPoints) return;
            // Ajout via prochain clic sur une arête (message)
            uiAlert('Maintenez Shift puis cliquez près d’une arête pour insérer un point.', 'Edition');
            // Le clic canvas gère l’insertion si editMode et pas sur un point
        });

        deletePointBtn.addEventListener('click', () => {
            if (!editMode || !editPoints) return;
            if (editDragging && typeof editDragging.idx === 'number') {
                if (editPoints.length <= 3) {
                    uiAlert('Un polygone doit avoir au moins 3 points.', 'Edition');
                    return;
                }
                editPoints.splice(editDragging.idx, 1);
                editDragging = null;
                redrawCanvas();
                return;
            }
            uiAlert('Sélectionnez un point (cliquez dessus) puis supprimez-le.', 'Edition');
        });

        saveEditBtn.addEventListener('click', async () => {
            if (!editMode) return;
            await saveEditedPolygon();
        });

        startDrawBtn.addEventListener('click', () => {
            if (!currentVideo) {
                uiAlert('Sélectionnez d\'abord une vidéo.', 'Dessin');
                return;
            }
            if (isCurrentVideoStreaming) {
                uiAlert('Mettez la détection en pause avant de dessiner.', 'Dessin');
                return;
            }

            let zoneNameSelected = drawZoneSelect.value;
            if (!zoneNameSelected) {
                uiAlert('Choisissez une zone (ou créez-en une).', 'Dessin');
                return;
            }
            if (zoneNameSelected === '__new__') {
                zoneNameSelected = drawZoneName.value.trim();
                if (!zoneNameSelected) {
                    uiAlert('Entrez un nom de zone.', 'Dessin');
                    drawZoneName.focus();
                    return;
                }
            }
            beginDrawing(drawMode, zoneNameSelected);
        });

        stopDrawBtn.addEventListener('click', () => {
            exitDrawingMode();
            drawExistingZones();
        });

        drawCanvas.addEventListener('click', (e) => {
            if (!isDrawing) return;

            const rect = drawCanvas.getBoundingClientRect();
            const scaleX = drawCanvas.width / rect.width;
            const scaleY = drawCanvas.height / rect.height;

            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            if (drawMode === 'line' && drawPoints.length >= 2) return;

            drawPoints.push([x, y]);
            redrawCanvas();
            updateFinishButtonState();
        });

        // Edition points (drag + insertion)
        drawCanvas.addEventListener('pointerdown', (e) => {
            if (!editMode || !editPoints) return;
            e.preventDefault();
            const p = getCanvasPointFromEvent(e);
            // Hit zone plus large pour attraper le point sans “créer à côté”
            const idx = nearestVertexIndex(editPoints, p, HANDLE_RADIUS * 3.8);
            if (idx >= 0) {
                editDragging = { idx };
                drawCanvas.setPointerCapture(e.pointerId);
                redrawCanvas();
            } else {
                // insertion de point sur arête: volontaire (Shift) pour éviter les insertions accidentelles
                const inserted = e.shiftKey ? insertPointOnNearestEdge(editPoints, p) : false;
                if (inserted) {
                    redrawCanvas();
                }
            }
        });

        drawCanvas.addEventListener('pointermove', (e) => {
            if (!editMode || !editPoints) return;
            if (!editDragging) return;
            const p = getCanvasPointFromEvent(e);
            const idx = editDragging.idx;
            if (typeof idx === 'number' && editPoints[idx]) {
                editPoints[idx][0] = p[0];
                editPoints[idx][1] = p[1];
                redrawCanvas();
            }
        });

        drawCanvas.addEventListener('pointerup', (e) => {
            if (!editMode) return;
            if (editDragging) {
                editDragging = null;
                redrawCanvas();
            }
        });

        undoBtn.addEventListener('click', () => {
            if (drawPoints.length > 0) {
                drawPoints.pop();
                redrawCanvas();
                updateFinishButtonState();
            }
        });

        finishBtn.addEventListener('click', async () => {
            const isOk = (drawMode === 'poly' && drawPoints.length >= 3) || (drawMode === 'line' && drawPoints.length >= 2);
            if (!isOk) return;

            const zoneName = activeDrawZoneName;
            const polygons = drawMode === 'line'
                ? [lineToPolygon(drawPoints[0], drawPoints[1], 12)]
                : [drawPoints];

            const prevCount = zonePolygonCounts[zoneName] ?? 0;

            await fetch('/api/zones', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    name: zoneName,
                    polygons,
                    video: currentVideo
                })
            });

            // Meta: mémorise le type du nouveau dessin côté navigateur (sans back)
            try {
                localStorage.setItem(
                    `drawmeta:${currentVideo}:${zoneName}:${prevCount}`,
                    drawMode === 'line' ? 'line' : 'include'
                );
            } catch {}
            // Ligne: mémorise aussi une direction par défaut pour afficher la flèche hors éditeur
            if (drawMode === 'line') {
                try {
                    const p1 = drawPoints[0];
                    const p2 = drawPoints[1];
                    const u = norm(sub(p2, p1));
                    const perp = [-u[1], u[0]];
                    setLineMeta(currentVideo, zoneName, prevCount, { p1, p2, dir: perp });
                } catch {}
            }

            // Recharge et prépare un autre dessin pour la même zone (append)
            await loadZones();
            drawExistingZones();
            drawPoints = [];
            redrawCanvas();
            updateFinishButtonState();

            // UX: on sélectionne automatiquement le dessin créé et on ouvre l'édition
            selectedAsset = { zone: zoneName, idx: prevCount };
            syncPresenceSelectionUI();
            exitDrawingMode();
            await drawExistingZones();
            // entre directement en mode édition pour ajuster sans message "sélectionnez un dessin"
            editSelectedBtn.click();
        });

        cancelBtn.addEventListener('click', () => {
            exitDrawingMode();
            drawExistingZones();
        });

        function lineToPolygon(p1, p2, thickness = 12) {
            const dx = p2[0] - p1[0];
            const dy = p2[1] - p1[1];
            const len = Math.hypot(dx, dy) || 1;
            const nx = -dy / len;
            const ny = dx / len;
            const half = thickness / 2;
            return [
                [p1[0] + nx * half, p1[1] + ny * half],
                [p1[0] - nx * half, p1[1] - ny * half],
                [p2[0] - nx * half, p2[1] - ny * half],
                [p2[0] + nx * half, p2[1] + ny * half]
            ];
        }

        function redrawCanvas() {
            ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            drawExistingZonesSync();

            // Overlay édition: points + polygone
            if (editMode && editPoints && editPoints.length >= 3) {
                ctx.beginPath();
                ctx.moveTo(editPoints[0][0], editPoints[0][1]);
                for (let i = 1; i < editPoints.length; i++) ctx.lineTo(editPoints[i][0], editPoints[i][1]);
                ctx.closePath();
                ctx.fillStyle = 'rgba(16, 176, 249, 0.12)';
                ctx.fill();
                ctx.strokeStyle = '#10B0F9';
                ctx.lineWidth = 3;
                ctx.stroke();

                editPoints.forEach((p, i) => {
                    const isActive = editDragging && editDragging.idx === i;
                    ctx.beginPath();
                    ctx.arc(p[0], p[1], HANDLE_RADIUS, 0, Math.PI * 2);
                    ctx.fillStyle = isActive ? '#F08321' : '#10B0F9';
                    ctx.fill();
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
            }

            if (drawPoints.length > 0) {
                if (drawMode === 'line') {
                    // Ligne: 2 points max
                    const p1 = drawPoints[0];
                    const p2 = drawPoints[1];

                    if (p2) {
                        const poly = lineToPolygon(p1, p2, 12);
                        ctx.beginPath();
                        ctx.moveTo(poly[0][0], poly[0][1]);
                        for (let i = 1; i < poly.length; i++) ctx.lineTo(poly[i][0], poly[i][1]);
                        ctx.closePath();
                        ctx.fillStyle = 'rgba(16, 176, 249, 0.18)';
                        ctx.fill();
                        ctx.strokeStyle = '#10B0F9';
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        // Ligne centrale
                        ctx.beginPath();
                        ctx.moveTo(p1[0], p1[1]);
                        ctx.lineTo(p2[0], p2[1]);
                        ctx.strokeStyle = '#10B0F9';
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }

                    drawPoints.forEach((p) => {
                        ctx.beginPath();
                        ctx.arc(p[0], p[1], 6, 0, Math.PI * 2);
                        ctx.fillStyle = '#10B0F9';
                        ctx.fill();
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    });
                } else {
                    // Zone: polygone
                    ctx.beginPath();
                    ctx.moveTo(drawPoints[0][0], drawPoints[0][1]);

                    for (let i = 1; i < drawPoints.length; i++) {
                        ctx.lineTo(drawPoints[i][0], drawPoints[i][1]);
                    }

                    if (drawPoints.length >= 3) {
                        ctx.closePath();
                        ctx.fillStyle = 'rgba(16, 176, 249, 0.25)';
                        ctx.fill();
                    }

                    ctx.strokeStyle = '#10B0F9';
                    ctx.lineWidth = 3;
                    ctx.stroke();

                    drawPoints.forEach((p, i) => {
                        ctx.beginPath();
                        ctx.arc(p[0], p[1], 6, 0, Math.PI * 2);
                        ctx.fillStyle = i === 0 ? '#22c55e' : '#10B0F9';
                        ctx.fill();
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    });
                }
            }
        }

        let cachedZones = {};

        async function drawExistingZones(force = false) {
            if (!currentVideo) return;

            // cache-bust: après save/edit, certains navigateurs gardent parfois l'ancienne réponse
            const url = `/api/zones/${encodeURIComponent(currentVideo)}${force ? `?t=${Date.now()}` : ''}`;
            const res = await fetch(url, { cache: 'no-store' });
            const data = await res.json();
            cachedZones = data.zones;

            drawExistingZonesSync();
        }

        function drawExistingZonesSync() {
            ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);

            for (const [name, zone] of Object.entries(cachedZones)) {
                const polygons = zone.polygons || [];
                for (let idx = 0; idx < polygons.length; idx++) {
                    const polygon = polygons[idx];
                    if (polygon.length < 3) continue;

                    const isSelectedDrawing =
                        selectedAsset &&
                        selectedAsset.zone === name &&
                        typeof selectedAsset.idx === 'number' &&
                        selectedAsset.idx === idx;

                    const isSelectedZone =
                        selectedAsset &&
                        selectedAsset.zone === name &&
                        typeof selectedAsset.idx !== 'number';

                    const type = getDrawType(currentVideo, name, idx);
                    const c = colorsForType(type, (isSelectedDrawing || isSelectedZone));
                    if (type === 'line' && polygon.length === 4) {
                        // Le backend stocke une ligne comme un quadrilatère fin: on la rend comme une vraie ligne + flèche
                        const a = [(polygon[0][0] + polygon[1][0]) / 2, (polygon[0][1] + polygon[1][1]) / 2];
                        const b = [(polygon[2][0] + polygon[3][0]) / 2, (polygon[2][1] + polygon[3][1]) / 2];
                        ctx.beginPath();
                        ctx.moveTo(a[0], a[1]);
                        ctx.lineTo(b[0], b[1]);
                        ctx.strokeStyle = c.stroke;
                        ctx.lineWidth = isSelectedDrawing ? 4 : (isSelectedZone ? 3 : 2);
                        ctx.setLineDash([]);
                        ctx.stroke();

                        // Flèche de sens (UI normale): visible, sans poignée
                        const meta = getLineMeta(currentVideo, name, idx);
                        const arrow = computeLineArrowFromMeta(meta, polygon);
                        if (arrow?.mid && arrow?.end) {
                            drawArrow(ctx, arrow.mid, arrow.end, c.stroke, { shaftWidth: 1.6, dashed: false, head: 22, wing: 13, outline: true, handle: false });
                        }
                    } else {
                        ctx.beginPath();
                        ctx.moveTo(polygon[0][0], polygon[0][1]);
                        for (let i = 1; i < polygon.length; i++) {
                            ctx.lineTo(polygon[i][0], polygon[i][1]);
                        }
                        ctx.closePath();

                        ctx.fillStyle = c.fill;
                        ctx.fill();
                        ctx.strokeStyle = c.stroke;
                        ctx.lineWidth = isSelectedDrawing ? 4 : (isSelectedZone ? 3 : 2);
                        ctx.stroke();
                    }

                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 14px Manrope, system-ui';
                    const label = isSelectedDrawing ? `${name} • ${type.toUpperCase()} ${idx + 1}` : name;
                    ctx.fillText(label, polygon[0][0] + 5, polygon[0][1] - 8);
                }
            }
        }

        // Detection
        startDetectionBtn.addEventListener('click', async () => {
            if (!currentVideo) return;

            isCurrentVideoStreaming = true;
            activeVideoStreams.add(currentVideo);
            presenceOkTsByVideo[currentVideo] = 0;
            markVideoRunStart(currentVideo);
            // Init local zone timers tick to avoid a big dt spike at first poll
            ensureZoneLive(currentVideo).lastTs = Date.now();

            videoFrame.classList.add('hidden');
            videoStream.classList.remove('hidden');
            drawCanvas.classList.add('hidden');

            videoStream.src = `/api/stream/${encodeURIComponent(currentVideo)}`;

            startDetectionBtn.classList.add('hidden');
            stopDetectionBtn.classList.remove('hidden');

            updateSteps();
            updateStatus('streaming');
            await updateActiveStreams();
        });

        stopDetectionBtn.addEventListener('click', async () => {
            if (!currentVideo) return;

            await fetch(`/api/stream/${encodeURIComponent(currentVideo)}/stop`, { method: 'POST' });

            isCurrentVideoStreaming = false;
            activeVideoStreams.delete(currentVideo);
            presenceOkTsByVideo[currentVideo] = 0;
            markVideoRunStop(currentVideo);
            // stop tick (freeze)
            if (zoneLiveTimersByVideo?.[currentVideo]) zoneLiveTimersByVideo[currentVideo].lastTs = 0;

            videoStream.src = '';
            videoStream.classList.add('hidden');
            videoFrame.src = `/api/videos/${encodeURIComponent(currentVideo)}/frame?t=${Date.now()}`;
            videoFrame.classList.remove('hidden');
            drawCanvas.classList.remove('hidden');

            startDetectionBtn.classList.remove('hidden');
            stopDetectionBtn.classList.add('hidden');

            updateSteps();
            updateStatus('ready');
            await updateActiveStreams();

            videoFrame.onload = () => {
                syncCanvasSize();
                drawExistingZones();
            };
        });

        stopAllBtn.addEventListener('click', async () => {
            await fetch('/api/streams/stop', { method: 'POST' });

            isCurrentVideoStreaming = false;
            markAllRunsStop();
            // freeze all local ticks
            try { Object.values(zoneLiveTimersByVideo).forEach(v => { if (v) v.lastTs = 0; }); } catch {}
            try { Object.keys(presenceOkTsByVideo).forEach(v => presenceOkTsByVideo[v] = 0); } catch {}
            activeVideoStreams.clear();

            if (currentVideo) {
                videoStream.src = '';
                videoStream.classList.add('hidden');
                videoFrame.src = `/api/videos/${encodeURIComponent(currentVideo)}/frame?t=${Date.now()}`;
                videoFrame.classList.remove('hidden');
                drawCanvas.classList.remove('hidden');

                videoFrame.onload = () => {
                    syncCanvasSize();
                    drawExistingZones();
                };
            }

            startDetectionBtn.classList.remove('hidden');
            stopDetectionBtn.classList.add('hidden');

            updateSteps();
            updateStatus('ready');
            await updateActiveStreams();
        });

        async function resetZoneTimer(name) {
            const ok = await uiConfirm(`Remettre le timer de "${name}" à zéro ?`, 'Timers');
            if (!ok) return;
            await fetch(`/api/zones/reset/${encodeURIComponent(name)}`, { method: 'POST' });
            resetLocalTimersZone(currentVideo, name);
            await loadZones();
        }

        // Blur toggle
        const toggleBlurBtn = document.getElementById('toggleBlurBtn');

        async function updateBlurButton() {
            const res = await fetch('/api/blur');
            const data = await res.json();
            if (data.enabled) {
                toggleBlurBtn.innerHTML = `
                    <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"/>
                    </svg>
                    Floutage: ON
                `;
                toggleBlurBtn.classList.add('btn-blur-on');
            } else {
                toggleBlurBtn.innerHTML = `
                    <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21"/>
                    </svg>
                    Floutage: OFF
                `;
                toggleBlurBtn.classList.remove('btn-blur-on');
            }
        }

        toggleBlurBtn.addEventListener('click', async () => {
            await fetch('/api/blur/toggle', { method: 'POST' });
            await updateBlurButton();
        });

        updateBlurButton();

        async function deleteZone(name) {
            const ok = await uiConfirm(`Supprimer la zone "${name}" de cette vidéo ?`, 'Suppression');
            if (!ok) return;
            await fetch(`/api/zones/${encodeURIComponent(currentVideo)}/${encodeURIComponent(name)}`, { method: 'DELETE' });

            // Invalider caches + purger états locaux pour recalculer les KPI (conformité interzone) sur les zones restantes
            try {
                // force refetch définitions zones
                zonesDefsFetchedByVideo[currentVideo] = false;
                zonesDefsFetchTsByVideo[currentVideo] = 0;
                delete zonesCacheByVideo[currentVideo];
                zonesCacheRefreshTs = 0;

                // purge timers/présence locaux pour la zone supprimée (évite pollution des moyennes)
                const v = zoneLiveTimersByVideo?.[currentVideo];
                if (v?.zones && name in v.zones) delete v.zones[name];
                const lp = linePassByVideo?.[currentVideo];
                if (lp && name in lp) delete lp[name];
                const pr = lastPresenceByVideo?.[currentVideo];
                if (pr && name in pr) delete pr[name];
                if (selectedAsset?.zone === name) selectedAsset = null;
            } catch {}

            await loadZones();
            drawExistingZones();
        }

        document.getElementById('deleteAllZonesBtn').addEventListener('click', async () => {
            const ok = await uiConfirm('Remettre tous les timers à zéro ?', 'Timers');
            if (!ok) return;
            await fetch('/api/zones/reset', { method: 'POST' });
            resetLocalTimersAll();
            await loadZones();
            drawExistingZones();
        });

        window.addEventListener('resize', syncCanvasSize);
    </script>
</body>
</html>
